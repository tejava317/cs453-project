"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchMetricListener = void 0;
/*
 * Copyright 2020-2023 Delft University of Technology and SynTest contributors
 *
 * This file is part of SynTest Framework - SynTest Core.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const metric_1 = require("@syntest/metric");
const module_1 = require("@syntest/module");
const search_1 = require("@syntest/search");
const Metrics_1 = require("../../Metrics");
class SearchMetricListener extends module_1.EventListenerPlugin {
    /**
     * Constructor.
     */
    constructor() {
        super("SearchMetricListener", "A listener that collects statistics about the search process.");
    }
    get metricManager() {
        if (!this.currentNamespace) {
            throw new Error("No namespace set");
        }
        return this._metricManager.getNamespaced(this.currentNamespace);
    }
    /**
     * Updates the collector.
     *
     * @param searchAlgorithm The search algorithm used
     * @param budgetManager The budget manager
     * @param terminationManager The termination manager
     */
    recordSeries(searchAlgorithm, subject, budgetManager) {
        const iterations = budgetManager
            .getBudgetObject(search_1.BudgetType.ITERATION)
            .getUsedBudget();
        const evaluations = budgetManager
            .getBudgetObject(search_1.BudgetType.EVALUATION)
            .getUsedBudget();
        let searchTime = budgetManager
            .getBudgetObject(search_1.BudgetType.SEARCH_TIME)
            .getUsedBudget();
        let totalTime = budgetManager
            .getBudgetObject(search_1.BudgetType.TOTAL_TIME)
            .getUsedBudget();
        searchTime = Math.round(searchTime * 1000) / 1000;
        totalTime = Math.round(totalTime * 1000) / 1000;
        const covered = [
            ...searchAlgorithm.getObjectiveManager().getCoveredObjectives(),
        ];
        const uncovered = [
            ...searchAlgorithm.getObjectiveManager().getUncoveredObjectives(),
        ];
        const coveredPaths = 0;
        const coveredBranches = covered.filter((objectiveFunction) => objectiveFunction instanceof search_1.BranchObjectiveFunction).length;
        const coveredFunctions = covered.filter((objectiveFunction) => objectiveFunction instanceof search_1.FunctionObjectiveFunction).length;
        const coveredExceptions = covered.filter((objectiveFunction) => objectiveFunction instanceof search_1.ExceptionObjectiveFunction).length;
        const coveredLines = 0;
        const coveredImplicitBranches = covered.filter((objectiveFunction) => objectiveFunction instanceof search_1.ImplicitBranchObjectiveFunction).length;
        const coveredObjectives = covered.length;
        // search times
        this.recordCoveredSeries(metric_1.SeriesUnit.SEARCH_TIME, searchTime, coveredPaths, coveredBranches, coveredFunctions, coveredLines, coveredImplicitBranches, coveredObjectives, coveredExceptions, covered, uncovered);
        this.recordCoveredSeries(metric_1.SeriesUnit.TOTAL_TIME, totalTime, coveredPaths, coveredBranches, coveredFunctions, coveredLines, coveredImplicitBranches, coveredObjectives, coveredExceptions, covered, uncovered);
        this.recordCoveredSeries(metric_1.SeriesUnit.ITERATION, iterations, coveredPaths, coveredBranches, coveredFunctions, coveredLines, coveredImplicitBranches, coveredObjectives, coveredExceptions, covered, uncovered);
        this.recordCoveredSeries(metric_1.SeriesUnit.EVALUATION, evaluations, coveredPaths, coveredBranches, coveredFunctions, coveredLines, coveredImplicitBranches, coveredObjectives, coveredExceptions, covered, uncovered);
    }
    recordCoveredSeries(seriesUnit, seriesIndex, coveredPaths, coveredBranches, coveredFunctions, coveredLines, coveredImplicitBranches, covered, coveredExceptions, coveredObjectives, uncoveredObjectives) {
        for (const objective of coveredObjectives) {
            this.metricManager.recordSeriesMeasurement(Metrics_1.SeriesName.OBJECTIVE_DISTANCE, seriesUnit, seriesIndex, objective.getIdentifier(), objective.getLowestDistance());
        }
        for (const objective of uncoveredObjectives) {
            this.metricManager.recordSeriesMeasurement(Metrics_1.SeriesName.OBJECTIVE_DISTANCE, seriesUnit, seriesIndex, objective.getIdentifier(), objective.getLowestDistance());
        }
        this.metricManager.recordSeries(Metrics_1.SeriesName.PATH_OBJECTIVES_COVERED, seriesUnit, seriesIndex, coveredPaths);
        this.metricManager.recordSeries(Metrics_1.SeriesName.BRANCH_OBJECTIVES_COVERED, seriesUnit, seriesIndex, coveredBranches);
        this.metricManager.recordSeries(Metrics_1.SeriesName.EXCEPTION_OBJECTIVES_COVERED, seriesUnit, seriesIndex, coveredExceptions);
        this.metricManager.recordSeries(Metrics_1.SeriesName.FUNCTION_OBJECTIVES_COVERED, seriesUnit, seriesIndex, coveredFunctions);
        this.metricManager.recordSeries(Metrics_1.SeriesName.LINE_OBJECTIVES_COVERED, seriesUnit, seriesIndex, coveredLines);
        this.metricManager.recordSeries(Metrics_1.SeriesName.IMPLICIT_BRANCH_OBJECTIVES_COVERED, seriesUnit, seriesIndex, coveredImplicitBranches);
        this.metricManager.recordSeries(Metrics_1.SeriesName.OBJECTIVES_COVERED, seriesUnit, seriesIndex, covered);
    }
    recordFinalProperties(searchAlgorithm) {
        const covered = [
            ...searchAlgorithm.getObjectiveManager().getCoveredObjectives(),
        ];
        const uncovered = [
            ...searchAlgorithm.getObjectiveManager().getUncoveredObjectives(),
        ];
        // record finals
        const coveredPaths = 0;
        const coveredBranches = covered.filter((objectiveFunction) => objectiveFunction instanceof search_1.BranchObjectiveFunction).length;
        const coveredFunctions = covered.filter((objectiveFunction) => objectiveFunction instanceof search_1.FunctionObjectiveFunction).length;
        const coveredExceptions = covered.filter((objectiveFunction) => objectiveFunction instanceof search_1.ExceptionObjectiveFunction).length;
        const coveredLines = 0;
        const coveredImplicitBranches = covered.filter((objectiveFunction) => objectiveFunction instanceof search_1.ImplicitBranchObjectiveFunction).length;
        const coveredObjectives = covered.length;
        this.metricManager.recordProperty(Metrics_1.PropertyName.PATH_OBJECTIVES_COVERED, coveredPaths.toString());
        this.metricManager.recordProperty(Metrics_1.PropertyName.BRANCH_OBJECTIVES_COVERED, coveredBranches.toString());
        this.metricManager.recordProperty(Metrics_1.PropertyName.FUNCTION_OBJECTIVES_COVERED, coveredFunctions.toString());
        this.metricManager.recordProperty(Metrics_1.PropertyName.EXCEPTION_OBJECTIVES_COVERED, coveredExceptions.toString());
        this.metricManager.recordProperty(Metrics_1.PropertyName.LINE_OBJECTIVES_COVERED, coveredLines.toString());
        this.metricManager.recordProperty(Metrics_1.PropertyName.IMPLICIT_BRANCH_OBJECTIVES_COVERED, coveredImplicitBranches.toString());
        this.metricManager.recordProperty(Metrics_1.PropertyName.OBJECTIVES_COVERED, coveredObjectives.toString());
        // record totals
        const totalPaths = 0;
        const totalBranches = coveredBranches +
            uncovered.filter((objectiveFunction) => objectiveFunction instanceof search_1.BranchObjectiveFunction).length;
        const totalFunctions = coveredFunctions +
            uncovered.filter((objectiveFunction) => objectiveFunction instanceof search_1.FunctionObjectiveFunction).length;
        const totalExceptions = coveredExceptions +
            uncovered.filter((objectiveFunction) => objectiveFunction instanceof search_1.ExceptionObjectiveFunction).length;
        const totalLines = 0;
        const totalImplicitBranches = coveredImplicitBranches +
            uncovered.filter((objectiveFunction) => objectiveFunction instanceof search_1.ImplicitBranchObjectiveFunction).length;
        const total = coveredObjectives + uncovered.length;
        this.metricManager.recordProperty(Metrics_1.PropertyName.PATH_OBJECTIVES_TOTAL, totalPaths.toString());
        this.metricManager.recordProperty(Metrics_1.PropertyName.BRANCH_OBJECTIVES_TOTAL, totalBranches.toString());
        this.metricManager.recordProperty(Metrics_1.PropertyName.FUNCTION_OBJECTIVES_TOTAL, totalFunctions.toString());
        this.metricManager.recordProperty(Metrics_1.PropertyName.EXCEPTION_OBJECTIVES_TOTAL, totalExceptions.toString());
        this.metricManager.recordProperty(Metrics_1.PropertyName.LINE_OBJECTIVES_TOTAL, totalLines.toString());
        this.metricManager.recordProperty(Metrics_1.PropertyName.IMPLICIT_BRANCH_OBJECTIVES_TOTAL, totalImplicitBranches.toString());
        this.metricManager.recordProperty(Metrics_1.PropertyName.OBJECTIVES_TOTAL, total.toString());
    }
    setupEventListener(metricManager) {
        this._metricManager = metricManager;
        process.on("searchStart", (searchAlgorithm, subject, budgetManager) => {
            // create a new metric manager for this search subject
            this.currentNamespace = subject.path;
            this.recordSeries(searchAlgorithm, subject, budgetManager);
        });
        process.on("searchIterationComplete", (searchAlgorithm, subject, budgetManager) => this.recordSeries(searchAlgorithm, subject, budgetManager));
        process.on("searchComplete", (searchAlgorithm, subject, budgetManager) => {
            this.recordSeries(searchAlgorithm, subject, budgetManager);
            this.recordFinalProperties(searchAlgorithm);
        });
    }
    getMetrics() {
        return Metrics_1.metrics;
    }
    getOptions() {
        return new Map();
    }
    getOptionChoices() {
        return [];
    }
}
exports.SearchMetricListener = SearchMetricListener;
//# sourceMappingURL=SearchMetricListener.js.map