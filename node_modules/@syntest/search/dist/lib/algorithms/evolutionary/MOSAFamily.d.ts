import { Logger } from "@syntest/logging";
import { Encoding } from "../../Encoding";
import { EncodingSampler } from "../../EncodingSampler";
import { ObjectiveManager } from "../../objective/managers/ObjectiveManager";
import { ObjectiveFunction } from "../../objective/ObjectiveFunction";
import { Procreation } from "../../operators/procreation/Procreation";
import { EvolutionaryAlgorithm } from "./EvolutionaryAlgorithm";
/**
 * Many-objective Sorting Algorithm (MOSA) family of search algorithms.
 *
 * Based on:
 * Reformulating Branch Coverage as a Many-Objective Optimization Problem
 * A. Panichella; F. K. Kifetew; P. Tonella
 *
 * Used by MOSA and DynaMOSA.
 *
 * @author Mitchell Olsthoorn
 * @author Annibale Panichella
 */
export declare class MOSAFamily<T extends Encoding> extends EvolutionaryAlgorithm<T> {
    protected static LOGGER: Logger;
    constructor(objectiveManager: ObjectiveManager<T>, encodingSampler: EncodingSampler<T>, procreation: Procreation<T>, populationSize: number);
    protected _environmentalSelection(size: number): void;
    /**
     * See: Preference sorting as discussed in the TSE paper for DynaMOSA
     *
     * @param population
     * @param objectiveFunctions
     */
    preferenceSortingAlgorithm(population: T[], objectiveFunctions: Set<ObjectiveFunction<T>>): T[][];
    /**
     * It retrieves the front of non-dominated solutions from a list
     */
    getNonDominatedFront(uncoveredObjectives: Set<ObjectiveFunction<T>>, remainingSolutions: T[]): T[];
    /**
     * Preference criterion in MOSA: for each objective, we select the test case closer to cover it.
     *
     * @param population
     * @param objectives list of objective to consider
     * @protected
     */
    preferenceCriterion(population: T[], objectives: Set<ObjectiveFunction<T>>): T[];
}
//# sourceMappingURL=MOSAFamily.d.ts.map