"use strict";
/*
 * Copyright 2020-2023 Delft University of Technology and SynTest contributors
 *
 * This file is part of SynTest Framework - SynTest Core.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PopulationBasedObjectiveManager = void 0;
const ExceptionObjectiveFunction_1 = require("../ExceptionObjectiveFunction");
const ObjectiveManager_1 = require("./ObjectiveManager");
/**
 * An abstract objective manager for algorithms based on populations.
 *
 * @author Mitchell Olsthoorn
 */
class PopulationBasedObjectiveManager extends ObjectiveManager_1.ObjectiveManager {
    /**
     * @inheritdoc
     */
    _handleCoveredObjective(objectiveFunction, _encoding) {
        // Update the objectives
        return this._updateObjectives(objectiveFunction);
    }
    /**
     * @inheritdoc
     */
    _handleUncoveredObjective(_objectiveFunction, _encoding, _distance) {
        // Do nothing
    }
    /**
     * The finalization step is used to update the archive with the final population.
     */
    // eslint-disable-next-line sonarjs/cognitive-complexity
    finalize(finalPopulation) {
        for (const encoding of finalPopulation) {
            if (encoding.getExecutionResult) {
                for (const objective of this._currentObjectives) {
                    if (encoding.getDistance(objective) === 0) {
                        ObjectiveManager_1.ObjectiveManager.LOGGER.debug("updating archive");
                        this._archive.update(objective, encoding, true);
                    }
                }
            }
            const executionResult = encoding.getExecutionResult();
            if (executionResult) {
                for (const objective of this._subject.getObjectives()) {
                    if (executionResult.coversId(objective.getIdentifier())) {
                        encoding.addMetaComment(`Covers objective: ${objective.getIdentifier()}`);
                    }
                }
            }
        }
        const encodings = this._archive.getEncodings();
        for (const encoding of encodings) {
            const uses = this._archive.getUses(encoding);
            for (const use of uses) {
                if (use instanceof ExceptionObjectiveFunction_1.ExceptionObjectiveFunction) {
                    encoding.addMetaComment(`Selected for:`);
                    for (const line of use.error.stack.split("\n")) {
                        encoding.addMetaComment(`\t${line}`);
                    }
                    encoding.addMetaComment("");
                }
                else {
                    encoding.addMetaComment(`Selected for objective: ${use.getIdentifier()}`);
                }
            }
        }
    }
}
exports.PopulationBasedObjectiveManager = PopulationBasedObjectiveManager;
//# sourceMappingURL=PopulationBasedObjectiveManager.js.map