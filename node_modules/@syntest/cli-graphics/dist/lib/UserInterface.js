"use strict";
/*
 * Copyright 2020-2021 Delft University of Technology and SynTest contributors
 *
 * This file is part of SynTest Framework - SynTest Core.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserInterface = void 0;
const chalk = require("chalk");
const cliProgress = require("cli-progress");
const figlet = require("figlet");
const table_1 = require("table");
class UserInterface {
    constructor() {
        this.barObject = undefined;
        this.bars = undefined;
    }
    print(text) {
        // If we are using progress bars, we need to print to above the bars
        if (this.barObject) {
            this.barObject.log(text + "\n");
            return;
        }
        console.log(text);
    }
    // Text manipulation methods
    indent(text, amount) {
        return " ".repeat(amount) + text;
    }
    // Direct print methods
    printTitle(text) {
        this.print(this.title(text));
    }
    printHeader(text) {
        this.print(this.header(text));
    }
    printError(text) {
        this.print(this.error(text));
    }
    printWarning(text) {
        this.print(this.warning(text));
    }
    printSuccess(text) {
        this.print(this.success(text));
    }
    printBold(text) {
        this.print(this.bold(text));
    }
    printTable(title, tableObject) {
        this.print(this.table(title, tableObject));
    }
    printItemization(title, items) {
        this.print(this.header(title));
        this.print(this.itemization(items));
    }
    startProgressBars(bars) {
        this.bars = new Map();
        this.barObject = new cliProgress.MultiBar({
            hideCursor: true,
            // eslint-disable-next-line @typescript-eslint/unbound-method
            format: this.barFormatter,
            barCompleteChar: "\u2588",
            barIncompleteChar: "\u2591",
        }, cliProgress.Presets.shades_grey);
        for (const bar of bars) {
            this.bars.set(bar.name, this.barObject.create(bar.maxValue, bar.value));
        }
    }
    updateProgressBar(bar) {
        if (this.bars === undefined) {
            throw new Error("Progress bars have not been started yet");
        }
        if (this.bars.has(bar.name) === false) {
            throw new Error(`Progress bar with name ${bar.name} does not exist`);
        }
        this.bars
            .get(bar.name)
            .update(bar.value, { meta: bar.meta, name: bar.name });
    }
    updateProgressBars(bars) {
        for (const bar of bars) {
            this.updateProgressBar(bar);
        }
    }
    stopProgressBars() {
        if (this.barObject === undefined) {
            throw new Error("Progress bars have not been started yet");
        }
        this.barObject.stop();
        this.barObject = undefined;
        this.bars = undefined;
    }
    barFormatter(options, parameters, payload) {
        const bar = chalk.green(options.barCompleteString.slice(0, Math.max(0, Math.round(parameters.progress * options.barsize)))) +
            options.barIncompleteString.slice(0, Math.max(0, options.barsize - Math.round(parameters.progress * options.barsize)));
        const percentage = Math.round(parameters.progress * 100);
        const string_ = `${bar} ${percentage}% | ETA: ${parameters.eta}s | ${parameters.value
        // eslint-disable-next-line sonarjs/no-nested-template-literals, @typescript-eslint/restrict-template-expressions
        }/${parameters.total} ${payload.meta ? `| ${payload.meta}` : ""} | ${payload.name}`;
        if (parameters.value >= parameters.total) {
            return chalk.greenBright(string_);
        }
        return string_;
    }
    // Private internal styling methods
    table(title, tableObject) {
        return (0, table_1.table)([
            tableObject.headers.map((element) => this.bold(element)),
            ...tableObject.rows,
            tableObject.footers.map((element) => this.bold(element)),
        ], {
            header: {
                alignment: "center",
                content: chalk.greenBright(chalk.bold(title)),
            },
        });
    }
    itemization(items, indentation = 2) {
        let text = "";
        for (const item of items) {
            text += this.indent(`- ${item.text}`, indentation) + "\n";
            if (item.subItems) {
                text += this.itemization(item.subItems, indentation + 2);
            }
        }
        return text;
    }
    title(text) {
        return chalk.bold(chalk.greenBright(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
        figlet.textSync(text, {
            horizontalLayout: "full",
            font: "Rectangles",
        })));
    }
    header(text) {
        return chalk.bgGreen(chalk.black(chalk.bold(`\n ${text} \n`)));
    }
    error(text) {
        return chalk.red(text);
    }
    warning(text) {
        return chalk.yellow(text);
    }
    success(text) {
        return chalk.green(text);
    }
    bold(text) {
        return chalk.bold(text);
    }
}
exports.UserInterface = UserInterface;
//# sourceMappingURL=UserInterface.js.map