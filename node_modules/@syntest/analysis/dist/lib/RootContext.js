"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RootContext = void 0;
/*
 * Copyright 2020-2023 Delft University of Technology and SynTest contributors
 *
 * This file is part of SynTest Framework - SynTest Core.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const path = require("node:path");
const diagnostics_1 = require("./util/diagnostics");
class RootContext {
    constructor(rootPath, sourceFactory, abstractSyntaxTreeFactory, controlFlowGraphFactory, targetFactory, dependencyFactory) {
        this._rootPath = path.resolve(rootPath);
        this.sourceFactory = sourceFactory;
        this.abstractSyntaxTreeFactory = abstractSyntaxTreeFactory;
        this.controlFlowGraphFactory = controlFlowGraphFactory;
        this.targetFactory = targetFactory;
        this.dependencyFactory = dependencyFactory;
        this._sources = new Map();
        this._abstractSyntaxTrees = new Map();
        this._controlFlowProgramMap = new Map();
        this._targetMap = new Map();
        this._dependenciesMap = new Map();
    }
    resolvePath(filePath) {
        const absolutePath = path.resolve(filePath);
        if (!this.verifyTargetPath(absolutePath)) {
            throw new Error((0, diagnostics_1.pathNotInRootPath)(this._rootPath, absolutePath));
        }
        return absolutePath;
    }
    verifyTargetPath(filePath) {
        return filePath.includes(this._rootPath);
    }
    /**
     * Loads the source code of the target
     * @param filePath
     */
    getSource(filePath) {
        const absolutePath = this.resolvePath(filePath);
        // this takes up too much memory we should do some kind of garbage collection if we want to save it all
        if (!this._sources.has(absolutePath)) {
            process.emit("sourceResolvingStart", this, absolutePath);
            this._sources.set(absolutePath, this.sourceFactory.produce(absolutePath));
            process.emit("sourceResolvingComplete", this, absolutePath, this._sources.get(absolutePath));
        }
        return this._sources.get(absolutePath);
    }
    /**
     * Loads the abstract syntax tree from the given filePath
     * @param filePath
     */
    getAbstractSyntaxTree(filePath) {
        const absolutePath = this.resolvePath(filePath);
        // this takes up too much memory we should do some kind of garbage collection if we want to save it all
        if (!this._abstractSyntaxTrees.has(absolutePath)) {
            process.emit("abstractSyntaxTreeResolvingStart", this, absolutePath);
            this._abstractSyntaxTrees.set(absolutePath, this.abstractSyntaxTreeFactory.convert(absolutePath, this.getSource(absolutePath)));
            process.emit("abstractSyntaxTreeResolvingComplete", this, absolutePath, this._abstractSyntaxTrees.get(absolutePath));
        }
        return this._abstractSyntaxTrees.get(absolutePath);
    }
    /**
     * Loads the control flow program from the given filePath
     * @param filePath
     */
    getControlFlowProgram(filePath) {
        const absolutePath = this.resolvePath(filePath);
        if (!this._controlFlowProgramMap.has(absolutePath)) {
            process.emit("controlFlowGraphResolvingStart", this, absolutePath);
            this._controlFlowProgramMap.set(absolutePath, this.controlFlowGraphFactory.convert(absolutePath, this.getAbstractSyntaxTree(absolutePath)));
            process.emit("controlFlowGraphResolvingComplete", this, absolutePath, this._controlFlowProgramMap.get(absolutePath));
        }
        return this._controlFlowProgramMap.get(absolutePath);
    }
    /**
     * Loads the target context from the given filePath
     * @param _filePath
     * @returns
     */
    getTarget(filePath) {
        const absolutePath = this.resolvePath(filePath);
        if (!this._targetMap.has(absolutePath)) {
            process.emit("targetExtractionStart", this, absolutePath);
            this._targetMap.set(absolutePath, this.targetFactory.extract(absolutePath, this.getAbstractSyntaxTree(absolutePath)));
            process.emit("targetExtractionComplete", this, absolutePath, this._targetMap.get(absolutePath));
        }
        return this._targetMap.get(absolutePath);
    }
    /**
     * gets all sub-targets from the given filePath
     * @param filePath
     */
    getSubTargets(filePath) {
        return this.getTarget(filePath).subTargets;
    }
    /**
     * Loads all dependencies from the given filePath
     * @param filePath
     */
    getDependencies(filePath) {
        const absolutePath = this.resolvePath(filePath);
        if (!this._dependenciesMap.has(absolutePath)) {
            process.emit("dependencyResolvingStart", this, absolutePath);
            this._dependenciesMap.set(absolutePath, this.dependencyFactory.extract(absolutePath, this.getAbstractSyntaxTree(absolutePath)));
            process.emit("dependencyResolvingComplete", this, absolutePath, this._dependenciesMap.get(absolutePath));
        }
        return this._dependenciesMap.get(absolutePath);
    }
}
exports.RootContext = RootContext;
//# sourceMappingURL=RootContext.js.map