"use strict";
/*
 * Copyright 2020-2023 Delft University of Technology and SynTest contributors
 *
 * This file is part of SynTest Framework - SynTest Javascript.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.JavaScriptDecoder = void 0;
const JavaScriptTestCase_1 = require("../testcase/JavaScriptTestCase");
const ClassActionStatement_1 = require("../testcase/statements/action/ClassActionStatement");
const FunctionCall_1 = require("../testcase/statements/action/FunctionCall");
const ObjectFunctionCall_1 = require("../testcase/statements/action/ObjectFunctionCall");
const assertionFunctionTemplate_1 = require("./assertionFunctionTemplate");
const ContextBuilder_1 = require("./ContextBuilder");
class JavaScriptDecoder {
    constructor(targetRootDirectory) {
        this.targetRootDirectory = targetRootDirectory;
    }
    decode(testCases, targetName, gatherAssertionData = false, sourceDirectory = "../instrumented") {
        if (testCases instanceof JavaScriptTestCase_1.JavaScriptTestCase) {
            testCases = [testCases];
        }
        const context = new ContextBuilder_1.ContextBuilder(this.targetRootDirectory, sourceDirectory);
        const tests = [];
        let assertionsPresent = false;
        for (const testCase of testCases) {
            if (testCase.assertionData) {
                assertionsPresent = true;
            }
            context.nextTestCase();
            const roots = testCase.roots;
            let decodings = roots.flatMap((root) => root.decode(context));
            if (decodings.length === 0) {
                throw new Error("No statements in test case");
            }
            let errorDecoding;
            if (testCase.assertionData && testCase.assertionData.error) {
                const index = testCase.assertionData.error.count;
                // delete statements after
                errorDecoding = decodings[index];
                decodings = decodings.slice(0, index);
            }
            if (decodings.length === 0) {
                throw new Error("No statements in test case after error reduction");
            }
            const metaCommentBlock = this.generateMetaComments(testCase);
            const testLines = this.generateTestLines(context, testCase, decodings, gatherAssertionData);
            const assertions = this.generateAssertions(testCase, errorDecoding);
            tests.push([...metaCommentBlock, ...testLines, ...assertions]);
        }
        const { imports, requires } = context.getImports(assertionsPresent);
        let beforeEachLines = [];
        if (requires.length > 0) {
            beforeEachLines = [
                ...requires.map((m) => `\tlet ${(m.left.includes(":") ? m.left.split(":")[1] : m.left)
                    .replace("{", "")
                    .replace("}", "")};`),
                `\tbeforeEach(() => {`,
                "\t\t// This is a hack to force the require cache to be emptied",
                "\t\t// Without this we would be using the same required object for each test",
                ...requires.map((m) => `\t\tdelete require.cache[${m.right.replace("require", "require.resolve")}];`),
                ...requires.map((m) => `\t\t(${m.left} = ${m.right});`),
                `\t});`,
                "",
            ];
        }
        const lines = [
            "// Imports",
            ...imports,
            gatherAssertionData ? assertionFunctionTemplate_1.assertionFunction : "",
            `describe('${targetName}', function() {`,
            ...beforeEachLines,
            ...tests.flatMap((testLines, index) => [
                `\tit("Test ${index + 1} for '${targetName}'", async () => {`,
                ...testLines.map((line) => `\t\t${line}`),
                index === tests.length - 1 ? "\t})" : "\t})\n",
            ]),
            "})",
        ];
        return lines.join("\n");
    }
    generateMetaComments(testCase) {
        const metaCommentBlock = [];
        for (const metaComment of testCase.metaComments) {
            metaCommentBlock.push(`// ${metaComment}`);
        }
        if (metaCommentBlock.length > 0) {
            metaCommentBlock.splice(0, 0, "// Meta information");
            metaCommentBlock.push("");
        }
        return metaCommentBlock;
    }
    generateTestLines(context, testCase, decodings, gatherAssertionData) {
        const testLines = [];
        if (gatherAssertionData) {
            testLines.push("let count = 0;", "try {");
        }
        for (const [index, value] of decodings.entries()) {
            const asString = value.decoded;
            if (testLines.includes(asString)) {
                // skip repeated statements
                continue;
            }
            testLines.push(asString);
            if (gatherAssertionData) {
                // add log per statement
                const variableName = context.getOrCreateVariableName(value.reference);
                testLines.push(`count = ${index + 1};`);
                if (value.reference instanceof FunctionCall_1.FunctionCall ||
                    value.reference instanceof ObjectFunctionCall_1.ObjectFunctionCall ||
                    value.reference instanceof ClassActionStatement_1.ClassActionStatement) {
                    testLines.push(`addAssertion('${testCase.id}', '${variableName}', ${variableName})`);
                }
            }
        }
        if (gatherAssertionData) {
            testLines.push(`} catch (e) {`, `\tsetError('${testCase.id}', e, count)`, "}");
        }
        if (testLines.length > 0) {
            testLines.splice(0, 0, "// Test");
            testLines.push("");
        }
        return testLines;
    }
    generateAssertions(testCase, errorDecoding) {
        const assertions = [];
        if (testCase.assertionData) {
            for (const [variableName, assertion] of Object.entries(testCase.assertionData.assertions)) {
                const original = assertion.value;
                let stringified = assertion.stringified;
                if (original === "undefined") {
                    assertions.push(`expect(${variableName}).to.equal(${original})`);
                    continue;
                }
                else if (original === "NaN") {
                    assertions.push(`expect(${variableName}).to.be.NaN`);
                    continue;
                }
                // TODO dirty hack because json.parse does not allow undefined/NaN
                // TODO undefined/NaN can happen in arrays
                stringified = stringified.replace("undefined", "null");
                stringified = stringified.replace("NaN", "null");
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                const value = JSON.parse(stringified);
                if (typeof value === "object" || typeof value === "function") {
                    assertions.push(`expect(JSON.parse(JSON.stringify(${variableName}))).to.deep.equal(${stringified})`);
                }
                else {
                    assertions.push(`expect(${variableName}).to.equal(${stringified})`);
                }
            }
        }
        if (errorDecoding) {
            assertions.push(`await expect((async () => {`, `\t${errorDecoding.decoded.split(" = ")[1]}`, `})()).to.be.rejectedWith(\`${testCase.assertionData.error.error.message}\`)`);
        }
        if (assertions.length > 0) {
            assertions.splice(0, 0, "// Assertions");
        }
        return assertions;
    }
}
exports.JavaScriptDecoder = JavaScriptDecoder;
//# sourceMappingURL=JavaScriptDecoder.js.map