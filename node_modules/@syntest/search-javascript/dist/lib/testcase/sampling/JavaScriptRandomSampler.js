"use strict";
/*
 * Copyright 2020-2023 Delft University of Technology and SynTest contributors
 *
 * This file is part of SynTest Framework - SynTest Javascript.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.JavaScriptRandomSampler = void 0;
const analysis_1 = require("@syntest/analysis");
const analysis_javascript_1 = require("@syntest/analysis-javascript");
const prng_1 = require("@syntest/prng");
const JavaScriptTestCase_1 = require("../JavaScriptTestCase");
const StatementPool_1 = require("../StatementPool");
const ConstructorCall_1 = require("../statements/action/ConstructorCall");
const MethodCall_1 = require("../statements/action/MethodCall");
const ArrayStatement_1 = require("../statements/complex/ArrayStatement");
const ArrowFunctionStatement_1 = require("../statements/complex/ArrowFunctionStatement");
const ObjectStatement_1 = require("../statements/complex/ObjectStatement");
const BoolStatement_1 = require("../statements/primitive/BoolStatement");
const IntegerStatement_1 = require("../statements/primitive/IntegerStatement");
const NullStatement_1 = require("../statements/primitive/NullStatement");
const NumericStatement_1 = require("../statements/primitive/NumericStatement");
const StringStatement_1 = require("../statements/primitive/StringStatement");
const UndefinedStatement_1 = require("../statements/primitive/UndefinedStatement");
const JavaScriptTestCaseSampler_1 = require("./JavaScriptTestCaseSampler");
class JavaScriptRandomSampler extends JavaScriptTestCaseSampler_1.JavaScriptTestCaseSampler {
    constructor(subject, constantPoolManager, constantPoolEnabled, constantPoolProbability, typePoolEnabled, typePoolProbability, statementPoolEnabled, statementPoolProbability, typeInferenceMode, randomTypeProbability, incorporateExecutionInformation, maxActionStatements, stringAlphabet, stringMaxLength, deltaMutationProbability, exploreIllegalValues) {
        super(subject, constantPoolManager, constantPoolEnabled, constantPoolProbability, typePoolEnabled, typePoolProbability, statementPoolEnabled, statementPoolProbability, typeInferenceMode, randomTypeProbability, incorporateExecutionInformation, maxActionStatements, stringAlphabet, stringMaxLength, deltaMutationProbability, exploreIllegalValues);
    }
    sample() {
        const roots = [];
        for (let index = 0; index < prng_1.prng.nextInt(1, this.maxActionStatements); // (i think its better to start with a single statement)
         index++) {
            this.statementPool = new StatementPool_1.StatementPool(roots);
            roots.push(this.sampleRoot());
        }
        this.statementPool = undefined;
        return new JavaScriptTestCase_1.JavaScriptTestCase(roots);
    }
    sampleRoot() {
        const targets = this._subject.getActionableTargets();
        if (this.statementPoolEnabled) {
            const constructor_ = this.statementPool.getRandomConstructor();
            if (constructor_ && prng_1.prng.nextBoolean(this.statementPoolProbability)) {
                // TODO ignoring getters and setters for now
                const targets = this.rootContext.getSubTargets(constructor_.typeIdentifier.split(":")[0]);
                const methods = (targets.filter((target) => target.type === analysis_1.TargetType.METHOD &&
                    target.methodType === "method" &&
                    target.classId === constructor_.classIdentifier));
                if (methods.length > 0) {
                    const method = prng_1.prng.pickOne(methods);
                    const type_ = this.rootContext
                        .getTypeModel()
                        .getObjectDescription(method.typeId);
                    const arguments_ = this.methodCallGenerator.sampleArguments(0, type_);
                    return new MethodCall_1.MethodCall(method.id, method.typeId, method.name, prng_1.prng.uniqueId(), arguments_, constructor_);
                }
            }
        }
        const action = prng_1.prng.pickOne(targets.filter((target) => (target.type === analysis_1.TargetType.FUNCTION && (0, analysis_javascript_1.isExported)(target)) ||
            (target.type === analysis_1.TargetType.CLASS && (0, analysis_javascript_1.isExported)(target)) ||
            (target.type === analysis_1.TargetType.OBJECT && (0, analysis_javascript_1.isExported)(target)) ||
            (target.type === analysis_1.TargetType.METHOD &&
                target.methodType !== "constructor" &&
                (0, analysis_javascript_1.isExported)(targets.find((classTarget) => classTarget.id === target.classId))) || // check whether parent class is exported
            (target.type === analysis_1.TargetType.OBJECT_FUNCTION &&
                (0, analysis_javascript_1.isExported)(targets.find((objectTarget) => objectTarget.id === target.objectId))) // check whether parent object is exported
        ));
        switch (action.type) {
            case analysis_1.TargetType.FUNCTION: {
                return this.sampleFunctionCall(0);
            }
            case analysis_1.TargetType.CLASS: {
                return this.sampleConstructorCall(0);
            }
            case analysis_1.TargetType.OBJECT: {
                return this.sampleConstantObject(0);
            }
            case analysis_1.TargetType.METHOD: {
                return this.sampleClassAction(0);
            }
            default: {
                return this.sampleObjectFunctionCall(0);
            }
        }
    }
    sampleFunctionCall(depth) {
        // get a random function
        const function_ = (prng_1.prng.pickOne(this._subject
            .getActionableTargetsByType(analysis_1.TargetType.FUNCTION)
            .filter((target) => (0, analysis_javascript_1.isExported)(target))));
        return this.functionCallGenerator.generate(depth, function_.id, function_.typeId, function_.id, function_.name, this.statementPool);
    }
    _getClass(id) {
        if (id) {
            const result = (this._subject
                .getActionableTargetsByType(analysis_1.TargetType.CLASS)
                .find((target) => target.id === id));
            if (!result) {
                throw new Error("missing class with id: " + id);
            }
            else if (!(0, analysis_javascript_1.isExported)(result)) {
                throw new Error("class with id: " + id + "is not exported");
            }
            return result;
        }
        // random
        return (prng_1.prng.pickOne(this._subject
            .getActionableTargetsByType(analysis_1.TargetType.CLASS)
            .filter((target) => (0, analysis_javascript_1.isExported)(target))));
    }
    sampleConstructorCall(depth, classId) {
        // get a random class
        const class_ = this._getClass(classId);
        // get the constructor of the class
        const constructor_ = this._subject
            .getActionableTargetsByType(analysis_1.TargetType.METHOD)
            .filter((method) => method.classId === class_.id &&
            method.methodType === "constructor");
        if (constructor_.length > 1) {
            throw new Error("Multiple constructors found for class");
        }
        if (constructor_.length === 0) {
            // default constructor no args
            const export_ = [...this.rootContext.getAllExports().values()]
                .flat()
                .find((export_) => export_.id === class_.id);
            return new ConstructorCall_1.ConstructorCall(class_.id, class_.typeId, class_.id, class_.name, prng_1.prng.uniqueId(), [], export_);
        }
        else {
            const action = constructor_[0];
            return this.constructorCallGenerator.generate(depth, action.id, action.typeId, class_.id, class_.name, this.statementPool);
        }
    }
    sampleClassAction(depth) {
        const targets = this._subject.getActionableTargets();
        const methods = this._subject
            .getActionableTargetsByType(analysis_1.TargetType.METHOD)
            .filter((method) => method.methodType !== "constructor" &&
            (0, analysis_javascript_1.isExported)(targets.find((classTarget) => classTarget.id === method.classId)));
        const randomMethod = prng_1.prng.pickOne(methods);
        switch (randomMethod.methodType) {
            case "method": {
                return this.sampleMethodCall(depth);
            }
            case "get": {
                return this.sampleGetter(depth);
            }
            case "set": {
                return this.sampleSetter(depth);
            }
            case "constructor": {
                throw new Error("invalid path");
            }
            // No default
        }
    }
    sampleMethodCall(depth) {
        const targets = this._subject.getActionableTargets();
        const methods = this._subject
            .getActionableTargetsByType(analysis_1.TargetType.METHOD)
            .filter((method) => method.methodType === "method")
            .filter((target) => (0, analysis_javascript_1.isExported)(targets.find((objectTarget) => objectTarget.id === target.classId)));
        const method = prng_1.prng.pickOne(methods);
        const class_ = this._getClass(method.classId);
        return this.methodCallGenerator.generate(depth, method.id, method.typeId, class_.id, method.name, this.statementPool);
    }
    sampleGetter(depth) {
        const targets = this._subject.getActionableTargets();
        const methods = this._subject
            .getActionableTargetsByType(analysis_1.TargetType.METHOD)
            .filter((method) => method.methodType === "get")
            .filter((target) => (0, analysis_javascript_1.isExported)(targets.find((objectTarget) => objectTarget.id === target.classId)));
        const method = prng_1.prng.pickOne(methods);
        const class_ = this._getClass(method.classId);
        return this.getterGenerator.generate(depth, method.id, method.id, class_.id, method.name, this.statementPool);
    }
    sampleSetter(depth) {
        const targets = this._subject.getActionableTargets();
        const methods = this._subject
            .getActionableTargetsByType(analysis_1.TargetType.METHOD)
            .filter((method) => method.methodType === "set")
            .filter((target) => (0, analysis_javascript_1.isExported)(targets.find((objectTarget) => objectTarget.id === target.classId)));
        const method = prng_1.prng.pickOne(methods);
        const class_ = this._getClass(method.classId);
        return this.setterGenerator.generate(depth, method.id, method.typeId, class_.id, method.name, this.statementPool);
    }
    _getObject(id) {
        if (id) {
            const result = (this._subject
                .getActionableTargetsByType(analysis_1.TargetType.OBJECT)
                .find((target) => target.id === id));
            if (!result) {
                throw new Error("missing object with id: " + id);
            }
            else if (!(0, analysis_javascript_1.isExported)(result)) {
                throw new Error("object with id: " + id + " is not exported");
            }
            return result;
        }
        // random
        return (prng_1.prng.pickOne(this._subject
            .getActionableTargetsByType(analysis_1.TargetType.OBJECT)
            .filter((target) => (0, analysis_javascript_1.isExported)(target))));
    }
    sampleConstantObject(depth, objectId) {
        // get a random object
        const object_ = this._getObject(objectId);
        return this.constantObjectGenerator.generate(depth, object_.id, object_.typeId, object_.id, object_.name, this.statementPool);
    }
    sampleObjectFunctionCall(depth) {
        const targets = this._subject.getActionableTargets();
        const functions = this._subject
            .getActionableTargetsByType(analysis_1.TargetType.OBJECT_FUNCTION)
            .filter((target) => (0, analysis_javascript_1.isExported)(targets.find((objectTarget) => objectTarget.id === target.objectId)));
        const randomFunction = prng_1.prng.pickOne(functions);
        const object_ = this._getObject(randomFunction.objectId);
        return this.objectFunctionCallGenerator.generate(depth, randomFunction.id, randomFunction.typeId, object_.id, randomFunction.name, this.statementPool);
    }
    // arguments
    sampleArrayArgument(depth, arrayId) {
        const arrayType = this.rootContext
            .getTypeModel()
            .getObjectDescription(arrayId);
        const childIds = [...arrayType.elements];
        if (childIds.length === 0) {
            // TODO should be done in the typemodel somehow
            // maybe create types for the subproperties by doing /main/array/id::1::1[element-index]
            // maybe create types for the subproperties by doing /main/array/id::1::1.property
            return this.sampleArgument(depth, "anon", "arrayElement");
        }
        const element = prng_1.prng.pickOne(childIds);
        return this.sampleArgument(depth, element, "arrayElement");
    }
    sampleObjectArgument(depth, objectTypeId, property) {
        const objectType = this.rootContext
            .getTypeModel()
            .getObjectDescription(objectTypeId);
        const value = objectType.properties.get(property);
        if (!value) {
            throw new Error(`Property ${property} not found in object ${objectTypeId}`);
        }
        return this.sampleArgument(depth, value, property);
    }
    sampleArgument(depth, id, name) {
        if (depth > 10) {
            // max depth
            // TODO should be any primitive type
            return this.sampleBool(id, id, name);
        }
        let chosenType;
        switch (this.typeInferenceMode) {
            case "none": {
                chosenType = this.rootContext
                    .getTypeModel()
                    .getRandomType(false, 1, id);
                break;
            }
            case "proportional": {
                chosenType = this.rootContext
                    .getTypeModel()
                    .getRandomType(this.incorporateExecutionInformation, this.randomTypeProbability, id);
                break;
            }
            case "ranked": {
                chosenType = this.rootContext
                    .getTypeModel()
                    .getHighestProbabilityType(this.incorporateExecutionInformation, this.randomTypeProbability, id);
                break;
            }
            default: {
                throw new Error("Invalid identifierDescription inference mode selected");
            }
        }
        // take from pool
        if (this.statementPoolEnabled) {
            const statementFromPool = this.statementPool.getRandomStatement(chosenType);
            if (statementFromPool &&
                prng_1.prng.nextBoolean(this.statementPoolProbability)) {
                return statementFromPool;
            }
        }
        const typeId = chosenType.includes("<>") ? chosenType.split("<>")[0] : id;
        const type = chosenType.includes("<>")
            ? chosenType.split("<>")[1]
            : chosenType;
        switch (type) {
            case "boolean": {
                return this.sampleBool(id, typeId, name);
            }
            case "string": {
                return this.sampleString(id, typeId, name);
            }
            case "numeric": {
                return this.sampleNumber(id, typeId, name);
            }
            case "integer": {
                return this.sampleInteger(id, typeId, name);
            }
            case "null": {
                return this.sampleNull(id, typeId, name);
            }
            case "undefined": {
                return this.sampleUndefined(id, typeId, name);
            }
            case "object": {
                return this.sampleObject(depth, id, typeId, name);
            }
            case "array": {
                return this.sampleArray(depth, id, typeId, name);
            }
            case "function": {
                return this.sampleArrowFunction(depth, id, typeId, name);
            }
            case "regex": {
                // TODO REGEX
                return this.sampleString(id, typeId, name);
            }
        }
        throw new Error(`unknown type: ${chosenType}`);
    }
    sampleObject(depth, id, typeId, name) {
        const typeObject = this.rootContext
            .getTypeModel()
            .getObjectDescription(typeId);
        if (this.typePoolEnabled) {
            // TODO maybe we should sample from the typepool for the other stuff as well (move this to sample arg for example)
            const typeFromTypePool = this.rootContext
                .getTypePool()
                // .getRandomMatchingType(typeObject)
                // TODO this prevents ONLY allows sampling of matching class constructors
                .getRandomMatchingType(typeObject, (type_) => type_.kind === analysis_javascript_1.DiscoveredObjectKind.CLASS);
            if (typeFromTypePool && prng_1.prng.nextBoolean(this.typePoolProbability)) {
                // always prefer type from type pool
                switch (typeFromTypePool.kind) {
                    case analysis_javascript_1.DiscoveredObjectKind.CLASS: {
                        // find constructor of class
                        const targets = this.rootContext.getSubTargets(typeFromTypePool.id.split(":")[0]);
                        const constructor_ = (targets.find((target) => target.type === analysis_1.TargetType.METHOD &&
                            target.methodType === "constructor" &&
                            target.classId === typeFromTypePool.id));
                        if (constructor_) {
                            return this.constructorCallGenerator.generate(depth, id, // variable id
                            constructor_.typeId, // constructor call id
                            typeFromTypePool.id, // class export id
                            name, this.statementPool);
                        }
                        return this.constructorCallGenerator.generate(depth, id, // variable id
                        typeFromTypePool.id, // constructor call id
                        typeFromTypePool.id, // class export id
                        name, this.statementPool);
                    }
                    case analysis_javascript_1.DiscoveredObjectKind.FUNCTION: {
                        return this.functionCallGenerator.generate(depth, id, typeFromTypePool.id, typeFromTypePool.id, name, this.statementPool);
                    }
                    case analysis_javascript_1.DiscoveredObjectKind.INTERFACE: {
                        // TODO
                        return this.constructorCallGenerator.generate(depth, id, typeFromTypePool.id, typeFromTypePool.id, name, this.statementPool);
                    }
                    case analysis_javascript_1.DiscoveredObjectKind.OBJECT: {
                        return this.constantObjectGenerator.generate(depth, id, typeFromTypePool.id, typeFromTypePool.id, name, this.statementPool);
                    }
                    // No default
                }
            }
        }
        const object_ = {};
        for (const key of typeObject.properties.keys()) {
            object_[key] = this.sampleObjectArgument(depth + 1, typeId, key);
        }
        return new ObjectStatement_1.ObjectStatement(id, typeId, name, prng_1.prng.uniqueId(), object_);
    }
    sampleArray(depth, id, typeId, name) {
        const elements = [];
        for (let index = 0; index < prng_1.prng.nextInt(0, this.maxActionStatements); index++) {
            elements.push(this.sampleArrayArgument(depth + 1, typeId));
        }
        return new ArrayStatement_1.ArrayStatement(id, typeId, name, prng_1.prng.uniqueId(), elements);
    }
    sampleArrowFunction(depth, id, typeId, name) {
        const typeObject = this.rootContext
            .getTypeModel()
            .getObjectDescription(typeId);
        const parameters = [];
        for (const [index, name] of typeObject.parameterNames.entries()) {
            parameters[index] = name;
        }
        // if some params are missing, fill them with fake params
        for (let index = 0; index < parameters.length; index++) {
            if (!parameters[index]) {
                parameters[index] = `param${index}`;
            }
        }
        if (typeObject.return.size === 0) {
            return new ArrowFunctionStatement_1.ArrowFunctionStatement(id, typeId, name, prng_1.prng.uniqueId(), parameters, undefined // maybe something random?
            );
        }
        const chosenReturn = prng_1.prng.pickOne([...typeObject.return]);
        return new ArrowFunctionStatement_1.ArrowFunctionStatement(id, typeId, name, prng_1.prng.uniqueId(), parameters, this.sampleArgument(depth + 1, chosenReturn, "return"));
    }
    sampleString(id, typeId, name) {
        let value;
        if (this.constantPoolEnabled &&
            prng_1.prng.nextBoolean(this.constantPoolProbability)) {
            value = this.constantPoolManager.contextConstantPool.getRandomString();
        }
        if (value === undefined) {
            value = "";
            const valueLength = prng_1.prng.nextInt(0, this.stringMaxLength - 1);
            for (let index = 0; index < valueLength; index++) {
                value += prng_1.prng.pickOne([...this.stringAlphabet]);
            }
        }
        return new StringStatement_1.StringStatement(id, typeId, name, prng_1.prng.uniqueId(), value);
    }
    // primitives
    sampleBool(id, typeId, name) {
        return new BoolStatement_1.BoolStatement(id, typeId, name, prng_1.prng.uniqueId(), prng_1.prng.nextBoolean());
    }
    sampleNull(id, typeId, name) {
        return new NullStatement_1.NullStatement(id, typeId, name, prng_1.prng.uniqueId());
    }
    sampleNumber(id, typeId, name) {
        // by default we create small numbers (do we need very large numbers?)
        const max = 1000;
        const min = -1000;
        const value = this.constantPoolEnabled && prng_1.prng.nextBoolean(this.constantPoolProbability)
            ? this.constantPoolManager.contextConstantPool.getRandomNumeric()
            : prng_1.prng.nextDouble(min, max);
        if (value === undefined) {
            prng_1.prng.nextDouble(min, max);
        }
        return new NumericStatement_1.NumericStatement(id, typeId, name, prng_1.prng.uniqueId(), value);
    }
    sampleInteger(id, typeId, name) {
        // by default we create small numbers (do we need very large numbers?)
        const max = 1000;
        const min = -1000;
        const value = this.constantPoolEnabled && prng_1.prng.nextBoolean(this.constantPoolProbability)
            ? this.constantPoolManager.contextConstantPool.getRandomInteger()
            : prng_1.prng.nextInt(min, max);
        if (value === undefined) {
            prng_1.prng.nextInt(min, max);
        }
        return new IntegerStatement_1.IntegerStatement(id, typeId, name, prng_1.prng.uniqueId(), value);
    }
    sampleUndefined(id, typeId, name) {
        return new UndefinedStatement_1.UndefinedStatement(id, typeId, name, prng_1.prng.uniqueId());
    }
}
exports.JavaScriptRandomSampler = JavaScriptRandomSampler;
//# sourceMappingURL=JavaScriptRandomSampler.js.map