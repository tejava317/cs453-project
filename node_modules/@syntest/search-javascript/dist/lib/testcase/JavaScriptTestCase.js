"use strict";
/*
 * Copyright 2020-2023 Delft University of Technology and SynTest contributors
 *
 * This file is part of SynTest Framework - SynTest Javascript.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.JavaScriptTestCase = void 0;
const logging_1 = require("@syntest/logging");
const prng_1 = require("@syntest/prng");
const search_1 = require("@syntest/search");
const StatementPool_1 = require("./StatementPool");
/**
 * JavaScriptTestCase class
 */
class JavaScriptTestCase extends search_1.Encoding {
    /**
     * Constructor.
     *
     * @param roots The roots of the tree chromosome of the test case
     */
    constructor(roots) {
        super();
        JavaScriptTestCase.LOGGER = (0, logging_1.getLogger)(JavaScriptTestCase.name);
        this._roots = roots.map((value) => value.copy());
        if (roots.length === 0) {
            throw new Error("Requires atleast one root action statement");
        }
        this._statementPool = new StatementPool_1.StatementPool(roots);
    }
    mutate(sampler) {
        JavaScriptTestCase.LOGGER.debug(`Mutating test case: ${this._id}`);
        sampler.statementPool = this._statementPool;
        const roots = this._roots.map((action) => action.copy());
        const choice = prng_1.prng.nextDouble();
        if (roots.length > 1) {
            if (choice < 0.33) {
                // 33% chance to add a root on this position
                const index = prng_1.prng.nextInt(0, roots.length);
                roots.splice(index, 0, sampler.sampleRoot());
            }
            else if (choice < 0.66) {
                // 33% chance to delete the root
                const index = prng_1.prng.nextInt(0, roots.length - 1);
                roots.splice(index, 1);
            }
            else {
                // 33% chance to just mutate the root
                const index = prng_1.prng.nextInt(0, roots.length - 1);
                roots.splice(index, 1, roots[index].mutate(sampler, 1));
            }
        }
        else {
            if (choice < 0.5) {
                // 50% chance to add a root on this position
                const index = prng_1.prng.nextInt(0, roots.length);
                roots.splice(index, 0, sampler.sampleRoot());
            }
            else {
                // 50% chance to just mutate the root
                const index = prng_1.prng.nextInt(0, roots.length - 1);
                roots.splice(index, 1, roots[index].mutate(sampler, 1));
            }
        }
        sampler.statementPool = undefined;
        return new JavaScriptTestCase(roots);
    }
    hashCode(decoder) {
        const string = decoder.decode(this, `${this.id}`);
        let hash = 0;
        for (let index = 0; index < string.length; index++) {
            const character = string.codePointAt(index);
            hash = (hash << 5) - hash + character;
            hash = hash & hash; // Convert to 32bit integer
        }
        return hash;
    }
    copy() {
        return new JavaScriptTestCase(this._roots.map((root) => root.copy()));
    }
    getLength() {
        return this.roots.length;
    }
    get roots() {
        return this._roots.map((value) => value.copy());
    }
    get assertionData() {
        return this._assertionData;
    }
    set assertionData(data) {
        this._assertionData = data;
    }
}
exports.JavaScriptTestCase = JavaScriptTestCase;
//# sourceMappingURL=JavaScriptTestCase.js.map