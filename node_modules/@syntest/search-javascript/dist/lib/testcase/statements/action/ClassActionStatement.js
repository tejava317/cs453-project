"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassActionStatement = void 0;
const search_1 = require("@syntest/search");
const ActionStatement_1 = require("./ActionStatement");
const ConstructorCall_1 = require("./ConstructorCall");
class ClassActionStatement extends ActionStatement_1.ActionStatement {
    /**
     * Constructor
     * @param identifierDescription the return type options of the function
     * @param ownType the return type of the function
     * @param uniqueId id of the gene
     * @param methodName the name of the function
     * @param args the arguments of the function
     */
    constructor(variableIdentifier, typeIdentifier, name, ownType, uniqueId, arguments_, constructor_) {
        super(variableIdentifier, typeIdentifier, name, ownType, uniqueId, arguments_);
        this._constructor = constructor_;
    }
    setChild(index, newChild) {
        if (!newChild) {
            throw new Error("Invalid new child!");
        }
        if (index < 0 || index > this.args.length) {
            throw new Error((0, search_1.shouldNeverHappen)(`Invalid index used index: ${index}`));
        }
        if (index === this.args.length) {
            if (!(newChild instanceof ConstructorCall_1.ConstructorCall)) {
                throw new TypeError((0, search_1.shouldNeverHappen)("should be a constructor"));
            }
            this._constructor = newChild;
        }
        else {
            this.args[index] = newChild;
        }
    }
    hasChildren() {
        return true;
    }
    getChildren() {
        return [...this.args, this._constructor];
    }
    get constructor_() {
        return this._constructor;
    }
}
exports.ClassActionStatement = ClassActionStatement;
//# sourceMappingURL=ClassActionStatement.js.map