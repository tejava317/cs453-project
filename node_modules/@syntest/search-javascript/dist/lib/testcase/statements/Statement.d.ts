import { TypeEnum } from "@syntest/analysis-javascript";
import { Encoding, EncodingSampler } from "@syntest/search";
import { ContextBuilder } from "../../testbuilding/ContextBuilder";
/**
 * @author Dimitri Stallenberg
 */
export declare abstract class Statement {
    private _variableIdentifier;
    private _typeIdentifier;
    private _name;
    private _ownType;
    protected _uniqueId: string;
    get variableIdentifier(): string;
    get typeIdentifier(): string;
    get name(): string;
    get ownType(): TypeEnum;
    get uniqueId(): string;
    /**
     * Constructor
     * @param identifierDescription
     * @param ownType
     * @param uniqueId
     */
    protected constructor(variableIdentifier: string, typeIdentifier: string, name: string, ownType: TypeEnum, uniqueId: string);
    /**
     * Mutates the gene
     * @param sampler   the sampler object that is being used
     * @param depth     the depth of the gene in the gene tree
     * @return          the mutated copy of the gene
     */
    abstract mutate(sampler: EncodingSampler<Encoding>, depth: number): Statement;
    /**
     * Creates an exact copy of the current gene
     * @return  the copy of the gene
     */
    abstract copy(): Statement;
    /**
     * Checks whether the gene has children
     * @return  whether the gene has children
     */
    abstract hasChildren(): boolean;
    /**
     * Gets all children of the gene
     * @return  The set of children of this gene
     */
    abstract getChildren(): Statement[];
    /**
     * Set a new child at a specified position
     *
     * WARNING: This function has side effects
     *
     * @param index the index position of the new child
     * @param newChild the new child
     */
    abstract setChild(index: number, newChild: Statement): void;
    /**
     * Decodes the statement
     * Note: when implementing this function please always decode the children of the statement before making getOrCreateVariableName on the context object.
     */
    abstract decode(context: ContextBuilder): Decoding[];
}
export interface Decoding {
    decoded: string;
    reference: Statement;
}
//# sourceMappingURL=Statement.d.ts.map