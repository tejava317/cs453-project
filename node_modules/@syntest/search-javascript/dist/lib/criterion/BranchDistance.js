"use strict";
/*
 * Copyright 2020-2023 Delft University of Technology and SynTest contributors
 *
 * This file is part of SynTest Framework - SynTest Javascript.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BranchDistance = void 0;
const core_1 = require("@babel/core");
const analysis_javascript_1 = require("@syntest/analysis-javascript");
const logging_1 = require("@syntest/logging");
const search_1 = require("@syntest/search");
const BranchDistanceVisitor_1 = require("./BranchDistanceVisitor");
class BranchDistance extends search_1.BranchDistance {
    constructor(syntaxForgiving, stringAlphabet) {
        super();
        this.syntaxForgiving = syntaxForgiving;
        BranchDistance.LOGGER = (0, logging_1.getLogger)("BranchDistance");
        this.stringAlphabet = stringAlphabet;
    }
    calculate(condition, variables, trueOrFalse) {
        if (condition === undefined || variables === undefined) {
            return 1;
        }
        const options = JSON.parse(JSON.stringify(analysis_javascript_1.defaultBabelOptions));
        const ast = (0, core_1.transformSync)(condition, options).ast;
        const visitor = new BranchDistanceVisitor_1.BranchDistanceVisitor(this.syntaxForgiving, this.stringAlphabet, variables, !trueOrFalse);
        (0, core_1.traverse)(ast, visitor);
        let distance = visitor._getDistance(condition);
        if (distance > 1 || distance < 0) {
            const variables_ = Object.entries(variables)
                .map(([key, value]) => `${key}=${String(value)}`)
                .join(", ");
            throw new Error(`Invalid distance: ${distance} for ${condition} -> ${String(trueOrFalse)}. Variables: ${variables_}`);
        }
        if (Number.isNaN(distance)) {
            throw new TypeError((0, search_1.shouldNeverHappen)("BranchDistance"));
        }
        if (distance === 1) {
            // We dont want a branch distance of 1 because then it will be equal to covering the oposite branch
            distance = 0.9999999999999999;
        }
        if (distance === 0) {
            // in general it should not be zero if used correctly so we give a warning
            const variables_ = Object.entries(variables)
                .map(([key, value]) => `${key}=${String(value)}`)
                .join(", ");
            BranchDistance.LOGGER.warn(`Calculated distance for condition '${condition}' -> ${String(trueOrFalse)}, is zero. Variables: ${variables_}`);
        }
        return distance;
    }
}
exports.BranchDistance = BranchDistance;
//# sourceMappingURL=BranchDistance.js.map