"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModuleManager = void 0;
/*
 * Copyright 2020-2023 Delft University of Technology and SynTest contributors
 *
 * This file is part of SynTest Framework - SynTest Core.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const node_fs_1 = require("node:fs");
const path = require("node:path");
const logging_1 = require("@syntest/logging");
const globalModules = require("global-modules");
const PluginType_1 = require("./extension/plugins/PluginType");
const Configuration_1 = require("./util/Configuration");
const diagnostics_1 = require("./util/diagnostics");
class ModuleManager {
    constructor(metricManager, storageManager, userInterface) {
        ModuleManager.LOGGER = (0, logging_1.getLogger)("ModuleManager");
        this._metricManager = metricManager;
        this._storageManager = storageManager;
        this._userInterface = userInterface;
        this._modules = new Map();
        this._tools = new Map();
        this._plugins = new Map();
        this._presets = new Map();
        this._toolsOfModule = new Map();
        this._pluginsOfModule = new Map();
        this._presetsOfModule = new Map();
    }
    get args() {
        return this._args;
    }
    set args(arguments_) {
        this._args = arguments_;
        for (const module of this.modules.values()) {
            module.args = arguments_;
        }
        for (const tool of this.tools.values()) {
            tool.args = arguments_;
        }
        for (const pluginsOfType of this.plugins.values()) {
            for (const plugin of pluginsOfType.values()) {
                plugin.args = arguments_;
            }
        }
        for (const preset of this.presets.values()) {
            preset.args = arguments_;
        }
    }
    get modules() {
        return this._modules;
    }
    get tools() {
        return this._tools;
    }
    get plugins() {
        return this._plugins;
    }
    get presets() {
        return this._presets;
    }
    get toolsOfModule() {
        return this._toolsOfModule;
    }
    get pluginsOfModule() {
        return this._pluginsOfModule;
    }
    get presetsOfModule() {
        return this._presetsOfModule;
    }
    getPlugin(type, name) {
        if (!this._plugins.has(type)) {
            throw new Error((0, diagnostics_1.pluginNotFound)(name, type));
        }
        if (!this._plugins.get(type).has(name)) {
            throw new Error((0, diagnostics_1.pluginNotFound)(name, type));
        }
        return this._plugins.get(type).get(name);
    }
    getPluginsOfType(type) {
        if (!this._plugins.has(type)) {
            return new Map();
        }
        return this._plugins.get(type);
    }
    async getMetrics() {
        const metrics = [];
        for (const tool of this.tools.values()) {
            if (tool.getMetrics) {
                const toolMetrics = await tool.getMetrics();
                ModuleManager.LOGGER.info(`Tool ${tool.name} has ${toolMetrics.length} metrics: [${toolMetrics
                    .map((metric) => Object.values(metric).join("."))
                    .join(", ")}]`);
                metrics.push(...toolMetrics);
            }
        }
        for (const [pluginType, pluginsOfType] of this.plugins.entries()) {
            if (pluginType === PluginType_1.PluginType.METRIC_MIDDLEWARE) {
                continue;
            }
            for (const plugin of pluginsOfType.values()) {
                if (plugin.getMetrics) {
                    const pluginMetrics = await plugin.getMetrics();
                    ModuleManager.LOGGER.info(`Plugin ${plugin.name} has ${pluginMetrics.length} metrics: [${pluginMetrics
                        .map((metric) => Object.values(metric).join("."))
                        .join(", ")}]`);
                    metrics.push(...pluginMetrics);
                }
            }
        }
        if (!this.plugins.has(PluginType_1.PluginType.METRIC_MIDDLEWARE)) {
            return metrics;
        }
        const metricMiddlewarePlugins = [
            ...this.plugins.get(PluginType_1.PluginType.METRIC_MIDDLEWARE).values(),
        ];
        // sort based on pipeline
        const order = this.args
            .metricMiddlewarePipeline;
        metricMiddlewarePlugins.sort((a, b) => order.indexOf(`metric-middleware-${a.name}`) -
            order.indexOf(`metric-middleware-${b.name}`));
        for (const plugin of metricMiddlewarePlugins) {
            // set previous metrics for this plugin
            plugin.setMetrics(metrics);
            if (plugin.getMetrics) {
                const pluginMetrics = await plugin.getMetrics();
                ModuleManager.LOGGER.info(`Metric Middleware Plugin ${plugin.name} has ${pluginMetrics.length} metrics: [${pluginMetrics
                    .map((metric) => Object.values(metric).join("."))
                    .join(", ")}]`);
                metrics.push(...pluginMetrics);
            }
        }
        return metrics;
    }
    async prepare() {
        ModuleManager.LOGGER.info("Preparing modules");
        for (const module of this.modules.values()) {
            if (module.prepare) {
                ModuleManager.LOGGER.info(`Preparing module: ${module.name}`);
                await module.prepare();
                ModuleManager.LOGGER.info(`Module prepared: ${module.name}`);
            }
        }
    }
    async cleanup() {
        ModuleManager.LOGGER.info("Running metric middleware pipeline");
        const metricPlugins = [
            ...this.getPluginsOfType(PluginType_1.PluginType.METRIC_MIDDLEWARE).values(),
        ];
        const order = this.args
            .metricMiddlewarePipeline;
        metricPlugins.sort((a, b) => order.indexOf(`metric-middleware-${a.name}`) -
            order.indexOf(`metric-middleware-${b.name}`));
        const metricMiddleWare = metricPlugins.map((plugin) => plugin.createMetricMiddleware(this._metricManager.metrics));
        await this._metricManager.runPipeline(metricMiddleWare);
        ModuleManager.LOGGER.info("Cleaning up modules");
        for (const module of this.modules.values()) {
            if (module.cleanup) {
                ModuleManager.LOGGER.info(`Cleaning up module: ${module.name}`);
                await module.cleanup();
                ModuleManager.LOGGER.info(`Module cleaned up: ${module.name}`);
            }
        }
    }
    getModulePath(module) {
        let modulePath = "";
        if (module.startsWith("file:")) {
            // It is a file path
            modulePath = path.resolve(module.replace("file:", ""));
            if (!(0, node_fs_1.existsSync)(modulePath)) {
                throw new Error((0, diagnostics_1.modulePathNotFound)(module));
            }
        }
        else {
            // It is a npm package
            modulePath = path.resolve(path.join("node_modules", module));
            if (!(0, node_fs_1.existsSync)(modulePath)) {
                // it is not locally installed lets try global
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                modulePath = path.resolve(path.join(globalModules, module));
            }
            if (!(0, node_fs_1.existsSync)(modulePath)) {
                // it is not installed locally nor globally
                // TODO maybe auto install?
                throw new Error((0, diagnostics_1.moduleNotInstalled)(module));
            }
        }
        return modulePath;
    }
    async loadModule(moduleId, modulePath) {
        var _a;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const { module } = await (_a = modulePath, Promise.resolve().then(() => require(_a)));
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access
        const moduleInstance = new module.default();
        // check requirements
        if (!moduleInstance.name) {
            throw new Error((0, diagnostics_1.moduleNotCorrectlyImplemented)("name", moduleId));
        }
        if (!moduleInstance.register) {
            throw new Error((0, diagnostics_1.moduleNotCorrectlyImplemented)("register", moduleId));
        }
        if (this.modules.has(moduleInstance.name)) {
            throw new Error((0, diagnostics_1.moduleAlreadyLoaded)(moduleInstance.name, moduleId));
        }
        this._modules.set(moduleInstance.name, moduleInstance);
        this._presetsOfModule.set(moduleInstance.name, []);
        this._toolsOfModule.set(moduleInstance.name, []);
        this._pluginsOfModule.set(moduleInstance.name, []);
        ModuleManager.LOGGER.info(`Module loaded: ${moduleId}`);
    }
    async loadModules(modulesIds) {
        // Load modules
        for (const module of modulesIds) {
            try {
                ModuleManager.LOGGER.info(`Loading module: ${module}`);
                const modulePath = this.getModulePath(module);
                await this.loadModule(module, modulePath);
            }
            catch (error) {
                console.log(error);
                throw new Error((0, diagnostics_1.moduleCannotBeLoaded)(module));
            }
        }
        const modules = [...this.modules.values()];
        for (const module of this._modules.values()) {
            await module.register(this, this._metricManager, this._storageManager, this._userInterface, modules);
        }
    }
    registerPreset(module, preset) {
        if (this._presets.has(preset.name)) {
            throw new Error((0, diagnostics_1.presetAlreadyLoaded)(preset.name));
        }
        ModuleManager.LOGGER.info(`Preset loaded: ${preset.name}`);
        this._presets.set(preset.name, preset);
        this._presetsOfModule.get(module.name).push(preset);
    }
    registerTool(module, tool) {
        if (this._tools.has(tool.name)) {
            throw new Error((0, diagnostics_1.toolAlreadyLoaded)(tool.name));
        }
        ModuleManager.LOGGER.info(`Tool loaded: ${tool.name}`);
        this._tools.set(tool.name, tool);
        this._toolsOfModule.get(module.name).push(tool);
    }
    registerPlugin(module, plugin) {
        if (!this._plugins.has(plugin.type)) {
            this._plugins.set(plugin.type, new Map());
        }
        if (this._plugins.get(plugin.type).has(plugin.name)) {
            throw new Error((0, diagnostics_1.pluginAlreadyLoaded)(plugin.name, plugin.type));
        }
        ModuleManager.LOGGER.info(`- Plugin loaded: ${plugin.type} - ${plugin.name}`);
        this._plugins.get(plugin.type).set(plugin.name, plugin);
        this._pluginsOfModule.get(module.name).push(plugin);
    }
    configureModules(yargs, presetChoice) {
        ModuleManager.LOGGER.info("Configuring modules");
        const presetOptions = [...this._presets.values()].map((preset) => preset.name);
        // add presets options to yargs by overriding it
        yargs.option("preset", {
            alias: [],
            choices: ["none", ...presetOptions],
            default: "none",
            description: "The preset you want to use",
            group: Configuration_1.OptionGroups.General,
            hidden: false,
            type: "string",
        });
        const plugins = [];
        for (const pluginsOfType of this._plugins.values()) {
            for (const plugin of pluginsOfType.values()) {
                plugins.push(plugin);
            }
        }
        for (const tool of this._tools.values()) {
            tool.addPluginOptions(plugins);
            tool.addPluginOptionChoices(plugins);
            yargs = yargs.command(tool);
        }
        ModuleManager.LOGGER.info("Setting preset");
        if (presetChoice === "none") {
            ModuleManager.LOGGER.info("No preset set");
            return yargs;
        }
        ModuleManager.LOGGER.info(`Preset set: ${presetChoice}`);
        if (!this._presets.has(presetChoice)) {
            ModuleManager.LOGGER.error(`Preset not found: ${presetChoice}`);
            throw new Error((0, diagnostics_1.presetNotFound)(presetChoice));
        }
        const presetObject = this._presets.get(presetChoice);
        yargs = yargs.middleware((arguments_) => presetObject.modifyArgs(arguments_));
        return yargs;
    }
    printModuleVersionTable() {
        const itemization = [];
        for (const module of this._modules.values()) {
            const tools = this._toolsOfModule.get(module.name);
            const plugins = this._pluginsOfModule.get(module.name);
            const presets = this._presetsOfModule.get(module.name);
            itemization.push({
                text: `Module: ${module.name} (${module.version})`,
                subItems: [
                    {
                        text: `Tools: ${tools.length > 0 ? "" : "[]"}`,
                        subItems: tools.map((tool) => ({
                            text: `${tool.name}: ${tool.describe}`,
                        })),
                    },
                    {
                        text: `Plugins: ${plugins.length > 0 ? "" : "[]"}`,
                        subItems: plugins.map((plugin) => ({
                            text: `${plugin.name}: ${plugin.describe}`,
                        })),
                    },
                    {
                        text: `Presets: ${presets.length > 0 ? "" : "[]"}`,
                        subItems: presets.map((preset) => ({
                            text: `${preset.name}: ${preset.describe}`,
                        })),
                    },
                ],
            });
        }
        this._userInterface.printItemization("Module loaded:", itemization);
    }
}
exports.ModuleManager = ModuleManager;
//# sourceMappingURL=ModuleManager.js.map