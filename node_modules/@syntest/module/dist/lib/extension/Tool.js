"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tool = void 0;
const diagnostics_1 = require("../util/diagnostics");
const Extension_1 = require("./Extension");
class Tool extends Extension_1.Extension {
    constructor(name, labels, describe, commands, toolOptions, handler) {
        super(name);
        this.builder = (yargs) => {
            // add all subcommands
            for (const command of this.commands) {
                yargs = yargs.command(command);
            }
            for (const option of this.toolOptions.keys()) {
                yargs = yargs.option(option, this.toolOptions.get(option));
            }
            // if no handler is provided, demand a subcommand
            if (!this.handler) {
                yargs = yargs.demandCommand();
            }
            return yargs.usage(`Usage: $0 ${this.command} <command> [options]`);
        };
        this.labels = labels;
        this.describe = describe;
        this.command = name;
        this.commands = commands;
        this.toolOptions = toolOptions;
        this.handler = handler;
    }
    /**
     * These two functions are separated because we need to be able to add choices to options that are added by plugins.
     * If the two functions are combined, the choices will be added to the original options, not the options added by plugins.
     */
    addPluginOptions(plugins) {
        for (const plugin of plugins) {
            const toolOptions = plugin.getOptions(this.name, this.labels);
            for (const option of toolOptions.keys()) {
                this.toolOptions.set(`${plugin.name}-${option}`, toolOptions.get(option));
            }
            for (const command of this.commands) {
                const commandOptions = plugin.getOptions(this.name, this.labels, command.command);
                for (const option of commandOptions.keys()) {
                    command.options.set(`${plugin.name}-${option}`, commandOptions.get(option));
                }
            }
        }
    }
    addPluginOptionChoices(plugins) {
        for (const plugin of plugins) {
            for (const option of this.toolOptions.keys()) {
                const addedChoices = plugin.getOptionChoices(option, this.name, this.labels);
                if (addedChoices.length === 0) {
                    continue;
                }
                if (!this.toolOptions.get(option).choices) {
                    throw new Error((0, diagnostics_1.cannotAddChoicesToOptionWithoutChoices)(option, plugin.name));
                }
                const newOption = {
                    ...this.toolOptions.get(option),
                };
                newOption.choices = [
                    ...this.toolOptions.get(option).choices,
                    ...addedChoices,
                ];
                this.toolOptions.set(option, newOption);
            }
            this._addCommandOptionChoices(plugin);
        }
    }
    _addCommandOptionChoices(plugin) {
        for (const command of this.commands) {
            for (const option of Object.keys(command.options)) {
                const addedChoices = plugin.getOptionChoices(option, this.name, this.labels, command.command);
                if (addedChoices.length === 0) {
                    continue;
                }
                if (!command.options.get(option).choices) {
                    throw new Error((0, diagnostics_1.cannotAddChoicesToOptionWithoutChoices)(option, plugin.name));
                }
                command.options.get(option).choices = [
                    ...command.options.get(option).choices,
                    ...addedChoices,
                ];
                const newOption = {
                    ...command.options.get(option),
                };
                newOption.choices = [
                    ...command.options.get(option).choices,
                    ...addedChoices,
                ];
                command.options.set(option, newOption);
            }
        }
    }
}
exports.Tool = Tool;
//# sourceMappingURL=Tool.js.map