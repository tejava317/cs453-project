import { UserInterface } from "@syntest/cli-graphics";
import { MetricManager } from "@syntest/metric";
import { StorageManager } from "@syntest/storage";
import { ModuleManager } from "../ModuleManager";
import { Extension } from "./Extension";
export declare abstract class Module extends Extension {
    version: Readonly<string>;
    constructor(name: string, version: string);
    abstract register(moduleManager: ModuleManager, metricManager: MetricManager, storageManager: StorageManager, userInterface: UserInterface, modules: Module[]): Promise<void> | void;
}
/**
 * We have defined both an abstract class and interface called Module here.
 * This is called 'merging' it allows an abstract class to have optional methods.
 */
export interface Module {
    /**
     * Called after the initialization step
     */
    prepare?(): Promise<void> | void;
    /**
     * Called before the exit step
     */
    cleanup?(): Promise<void> | void;
}
//# sourceMappingURL=Module.d.ts.map