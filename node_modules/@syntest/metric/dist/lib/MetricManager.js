"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricManager = void 0;
/*
 * Copyright 2020-2023 Delft University of Technology and SynTest contributors
 *
 * This file is part of SynTest Framework - SynTest Core.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logging_1 = require("@syntest/logging");
const diagnostics_1 = require("./util/diagnostics");
class MetricManager {
    getNamespaced(namespace) {
        if (!this._namespacedManagers.has(namespace)) {
            const manager = new MetricManager(namespace);
            manager.metrics = this.metrics;
            this._namespacedManagers.set(namespace, manager);
        }
        const namespacedManager = this._namespacedManagers.get(namespace);
        if (namespacedManager === undefined) {
            throw new Error((0, diagnostics_1.shouldNeverHappen)("MetricManager"));
        }
        return namespacedManager;
    }
    constructor(namespace) {
        this._metrics = undefined;
        this._outputMetrics = undefined;
        MetricManager.LOGGER = (0, logging_1.getLogger)("MetricManager");
        this._namespace = namespace;
        this._namespacedManagers = new Map();
        this.properties = new Map();
        this.distributions = new Map();
        this.series = new Map();
        this.seriesDistributions = new Map();
        this.seriesMeasurements = new Map();
    }
    get outputMetrics() {
        if (!this._outputMetrics) {
            throw new Error("Output metrics not set");
        }
        return this._outputMetrics;
    }
    // eslint-disable-next-line sonarjs/cognitive-complexity
    merge(other) {
        // Merge properties
        for (const [name, value] of other.properties.entries()) {
            if (value.length === 0) {
                // don't overwrite with empty values
                continue;
            }
            this.properties.set(name, value);
        }
        // Merge distributions
        for (const [name, distribution] of other.distributions.entries()) {
            this.distributions.set(name, [...distribution]);
        }
        // Merge series
        for (const [name, seriesByType] of other.series.entries()) {
            const seriesMetricMap = new Map();
            for (const [unit, series] of seriesByType.entries()) {
                seriesMetricMap.set(unit, new Map(series));
            }
            this.series.set(name, seriesMetricMap);
        }
        // Merge series distributions
        for (const [name, seriesDistributionsByType,] of other.seriesDistributions.entries()) {
            const seriesDistributionsMetricMap = new Map();
            for (const [unit, series] of seriesDistributionsByType.entries()) {
                const seriesDistributionsMap = new Map();
                for (const [seriesIndex, distribution] of series.entries()) {
                    seriesDistributionsMap.set(seriesIndex, [...distribution]);
                }
                seriesDistributionsMetricMap.set(unit, seriesDistributionsMap);
            }
            this.seriesDistributions.set(name, seriesDistributionsMetricMap);
        }
        // Merge series measurements
        for (const [name, seriesMeasurementsByType,] of other.seriesMeasurements.entries()) {
            const seriesMeasurementsMetricMap = new Map();
            for (const [unit, series] of seriesMeasurementsByType.entries()) {
                const seriesMeasurementsMap = new Map();
                for (const [seriesIndex, measurements] of series.entries()) {
                    const measurementsMap = new Map();
                    for (const [key, value] of measurements.entries()) {
                        measurementsMap.set(key, value);
                    }
                    seriesMeasurementsMap.set(seriesIndex, measurementsMap);
                }
                seriesMeasurementsMetricMap.set(unit, seriesMeasurementsMap);
            }
            this.seriesMeasurements.set(name, seriesMeasurementsMetricMap);
        }
    }
    getMergedNamespacedManager(namespace) {
        if (!this._namespacedManagers.has(namespace)) {
            throw new Error(`Namespace ${namespace} not registered`);
        }
        const namespaced = this.getNamespaced(namespace);
        const manager = new MetricManager(`${this._namespace}.${namespace}`);
        manager._metrics = this._metrics;
        manager._outputMetrics = this._outputMetrics;
        manager.merge(this);
        manager.merge(namespaced);
        return manager;
    }
    // eslint-disable-next-line sonarjs/cognitive-complexity
    setOutputMetrics(metrics) {
        if (metrics.includes("*")) {
            this._outputMetrics = [...this.metrics];
        }
        else {
            const outputMetrics = metrics.map((metric) => {
                const split = metric.split(".");
                const found = this.metrics.find((m) => {
                    if (m.type !== split[0]) {
                        return false;
                    }
                    switch (m.type) {
                        case "property":
                        case "distribution": {
                            return split[1] === "*" || m.name === split[1];
                        }
                        case "series":
                        case "series-distribution":
                        case "series-measurement": {
                            return ((split[1] === "*" || m.name === split[1]) &&
                                (split[2] === "*" || m.seriesUnit === split[2]));
                        }
                    }
                    return false;
                });
                if (!found) {
                    throw new Error(`Output metric ${metric} not found`);
                }
                return found;
            });
            this._outputMetrics = outputMetrics;
        }
        for (const manager of this.namespacedManagers.values()) {
            manager._outputMetrics = this.outputMetrics;
        }
    }
    get metrics() {
        if (!this._metrics) {
            throw new Error("Metrics not set");
        }
        return this._metrics;
    }
    set metrics(metrics) {
        this._metrics = metrics;
        for (const metric of this._metrics) {
            switch (metric.type) {
                case "property": {
                    this.properties.set(metric.name, "");
                    break;
                }
                case "distribution": {
                    this.distributions.set(metric.name, []);
                    break;
                }
                case "series": {
                    if (!this.series.has(metric.name)) {
                        this.series.set(metric.name, new Map());
                    }
                    this.series.get(metric.name).set(metric.seriesUnit, new Map());
                    break;
                }
                case "series-distribution": {
                    if (!this.seriesDistributions.has(metric.name)) {
                        this.seriesDistributions.set(metric.name, new Map());
                    }
                    this.seriesDistributions
                        .get(metric.name)
                        .set(metric.seriesUnit, new Map());
                    break;
                }
                case "series-measurement": {
                    if (!this.seriesMeasurements.has(metric.name)) {
                        this.seriesMeasurements.set(metric.name, new Map());
                    }
                    this.seriesMeasurements
                        .get(metric.name)
                        .set(metric.seriesUnit, new Map());
                    break;
                }
            }
        }
    }
    get namespacedManagers() {
        return this._namespacedManagers;
    }
    get namespace() {
        return this._namespace;
    }
    async runPipeline(middleware) {
        for (const _middleware of middleware) {
            MetricManager.LOGGER.debug(`Running middleware ${_middleware.constructor.name}`);
            await _middleware.run(this);
        }
        for (const manager of this._namespacedManagers.values()) {
            await manager.runPipeline(middleware);
        }
    }
    recordProperty(property, value) {
        MetricManager.LOGGER.debug(`Recording property ${property} = ${value}`);
        if (!this.properties.has(property)) {
            throw new Error((0, diagnostics_1.propertyNotRegistered)(property));
        }
        this.properties.set(property, value);
    }
    recordDistribution(distributionName, value) {
        MetricManager.LOGGER.debug(`Recording distribution ${distributionName} = ${value}`);
        if (!this.distributions.has(distributionName)) {
            throw new Error((0, diagnostics_1.distributionNotRegistered)(distributionName));
        }
        this.distributions.get(distributionName).push(value);
    }
    recordSeries(seriesName, seriesUnit, seriesIndex, value) {
        MetricManager.LOGGER.debug(`Recording series ${seriesName}.${seriesUnit}[${seriesIndex}] = ${value}`);
        if (!this.series.has(seriesName)) {
            throw new Error((0, diagnostics_1.seriesNotRegistered)(seriesName));
        }
        if (!this.series.get(seriesName).has(seriesUnit)) {
            throw new Error((0, diagnostics_1.seriesUnitNotRegistered)(seriesName, seriesUnit));
        }
        this.series.get(seriesName).get(seriesUnit).set(seriesIndex, value);
    }
    recordSeriesDistribution(seriesDistributionName, seriesUnit, seriesIndex, value) {
        MetricManager.LOGGER.debug(`Recording series distribution ${seriesDistributionName}.${seriesUnit}[${seriesIndex}] = ${value}`);
        if (!this.seriesDistributions.has(seriesDistributionName)) {
            throw new Error((0, diagnostics_1.seriesDistributionNotRegistered)(seriesDistributionName));
        }
        if (!this.seriesDistributions.get(seriesDistributionName).has(seriesUnit)) {
            throw new Error((0, diagnostics_1.seriesDistributionTypeNotRegistered)(seriesDistributionName, seriesUnit));
        }
        if (!this.seriesDistributions
            .get(seriesDistributionName)
            .get(seriesUnit)
            .has(seriesIndex)) {
            this.seriesDistributions
                .get(seriesDistributionName)
                .get(seriesUnit)
                .set(seriesIndex, []);
        }
        this.seriesDistributions
            .get(seriesDistributionName)
            .get(seriesUnit)
            .get(seriesIndex)
            .push(value);
    }
    recordSeriesMeasurement(seriesMeasurementName, seriesUnit, seriesIndex, key, value) {
        MetricManager.LOGGER.debug(`Recording series measurement ${seriesMeasurementName}.${seriesUnit}[${seriesIndex}].${key} = ${value}`);
        if (!this.seriesMeasurements.has(seriesMeasurementName)) {
            throw new Error((0, diagnostics_1.seriesDistributionNotRegistered)(seriesMeasurementName));
        }
        if (!this.seriesMeasurements.get(seriesMeasurementName).has(seriesUnit)) {
            throw new Error((0, diagnostics_1.seriesDistributionTypeNotRegistered)(seriesMeasurementName, seriesUnit));
        }
        if (!this.seriesMeasurements
            .get(seriesMeasurementName)
            .get(seriesUnit)
            .has(seriesIndex)) {
            this.seriesMeasurements
                .get(seriesMeasurementName)
                .get(seriesUnit)
                .set(seriesIndex, new Map());
        }
        this.seriesMeasurements
            .get(seriesMeasurementName)
            .get(seriesUnit)
            .get(seriesIndex)
            .set(key, value);
    }
    getProperty(property) {
        MetricManager.LOGGER.debug(`Getting property ${property}`);
        return this.properties.get(property);
    }
    getDistribution(distributionName) {
        MetricManager.LOGGER.debug(`Getting distribution ${distributionName}`);
        return this.distributions.get(distributionName);
    }
    getSeries(seriesName, seriesUnit) {
        MetricManager.LOGGER.debug(`Getting series ${seriesName}.${seriesUnit}`);
        if (!this.series.has(seriesName)) {
            return undefined;
        }
        return this.series.get(seriesName).get(seriesUnit);
    }
    getSeriesDistribution(seriesDistributionName, seriesUnit) {
        MetricManager.LOGGER.debug(`Getting series distribution ${seriesDistributionName}.${seriesUnit}`);
        if (!this.seriesDistributions.has(seriesDistributionName)) {
            return undefined;
        }
        return this.seriesDistributions.get(seriesDistributionName).get(seriesUnit);
    }
    getSeriesMeasurement(seriesMeasurementName, seriesUnit) {
        MetricManager.LOGGER.debug(`Getting series measurement ${seriesMeasurementName}.${seriesUnit}`);
        if (!this.seriesMeasurements.has(seriesMeasurementName)) {
            return undefined;
        }
        return this.seriesMeasurements.get(seriesMeasurementName).get(seriesUnit);
    }
    getAllProperties() {
        return this.properties;
    }
    getAllDistributions() {
        return this.distributions;
    }
    getAllSeries() {
        return this.series;
    }
    getAllSeriesDistributions() {
        return this.seriesDistributions;
    }
    getAllSeriesMeasurements() {
        return this.seriesMeasurements;
    }
    collectProperties(wanted) {
        const properties = new Map();
        for (const property of wanted) {
            const value = this.getProperty(property.name);
            properties.set(property.name, value);
        }
        return properties;
    }
    collectDistributions(wanted) {
        const distributions = new Map();
        for (const distribution of wanted) {
            const value = this.getDistribution(distribution.name);
            distributions.set(distribution.name, value);
        }
        return distributions;
    }
    collectSeries(wanted) {
        const series = new Map();
        for (const seriesMetric of wanted) {
            const value = this.getSeries(seriesMetric.name, seriesMetric.seriesUnit);
            if (!series.has(seriesMetric.name)) {
                series.set(seriesMetric.name, new Map());
            }
            series.get(seriesMetric.name).set(seriesMetric.seriesUnit, value);
        }
        return series;
    }
    collectSeriesDistributions(wanted) {
        const seriesDistributions = new Map();
        for (const seriesDistribution of wanted) {
            const value = this.getSeriesDistribution(seriesDistribution.name, seriesDistribution.seriesUnit);
            if (!seriesDistributions.has(seriesDistribution.name)) {
                seriesDistributions.set(seriesDistribution.name, new Map());
            }
            seriesDistributions
                .get(seriesDistribution.name)
                .set(seriesDistribution.seriesUnit, value);
        }
        return seriesDistributions;
    }
    collectSeriesMeasurements(wanted) {
        const seriesMeasurements = new Map();
        for (const seriesMeasurement of wanted) {
            const value = this.getSeriesMeasurement(seriesMeasurement.name, seriesMeasurement.seriesUnit);
            if (!seriesMeasurements.has(seriesMeasurement.name)) {
                seriesMeasurements.set(seriesMeasurement.name, new Map());
            }
            seriesMeasurements
                .get(seriesMeasurement.name)
                .set(seriesMeasurement.seriesUnit, value);
        }
        return seriesMeasurements;
    }
}
exports.MetricManager = MetricManager;
//# sourceMappingURL=MetricManager.js.map