import { NodePath } from "@babel/core";
import * as t from "@babel/types";
import { AbstractSyntaxTreeVisitor } from "@syntest/ast-visitor-javascript";
import { ControlFlowProgram } from "@syntest/cfg";
import { Logger } from "@syntest/logging";
export declare class ControlFlowGraphVisitor extends AbstractSyntaxTreeVisitor {
    protected static LOGGER: Logger;
    private _nodesList;
    private _nodes;
    private _edges;
    private _labeledBreakNodes;
    private _labeledContinueNodes;
    private _regularBreakNodesStack;
    private _regularContinueNodesStack;
    private _returnNodes;
    private _throwNodes;
    private _functions;
    private _currentParents;
    private _edgeType;
    get cfg(): ControlFlowProgram;
    constructor(filePath: string, syntaxForgiving: boolean);
    private _getBreakNodes;
    private _getContinueNodes;
    private _getLocation;
    private _createNode;
    _getPlaceholderNodeId(path: NodePath<t.Node>): string;
    /**
     * Create a placeholder node for a node that is not in the AST, but is used in the CFG.
     * Uses the end location of the parent node as the start and end location of the placeholder node.
     * @param path
     * @returns
     */
    private _createPlaceholderNode;
    private _createEdge;
    /**
     * Connects the current parents to the given node
     * It uses the current edge type and resets it back to normal afterwards
     *
     * @param node
     */
    private _connectToParents;
    Block: (path: NodePath<t.Block>) => void;
    Function: (path: NodePath<t.Function>) => void;
    Statement: (path: NodePath<t.Statement>) => void;
    Expression: (path: NodePath<t.Expression>) => void;
    Conditional: (path: NodePath<t.Conditional>) => void;
    LabeledStatement: (path: NodePath<t.LabeledStatement>) => void;
    DoWhileStatement: (path: NodePath<t.DoWhileStatement>) => void;
    WhileStatement: (path: NodePath<t.WhileStatement>) => void;
    ForStatement: (path: NodePath<t.ForStatement>) => void;
    ForInStatement: (path: NodePath<t.ForInStatement>) => void;
    ForOfStatement: (path: NodePath<t.ForOfStatement>) => void;
    SwitchStatement: (path: NodePath<t.SwitchStatement>) => void;
    BreakStatement: (path: NodePath<t.BreakStatement>) => void;
    ContinueStatement: (path: NodePath<t.ContinueStatement>) => void;
    ReturnStatement: (path: NodePath<t.ReturnStatement>) => void;
    ThrowStatement: (path: NodePath<t.ThrowStatement>) => void;
}
//# sourceMappingURL=ControlFlowGraphVisitor.d.ts.map