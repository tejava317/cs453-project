"use strict";
/*
 * Copyright 2020-2023 Delft University of Technology and SynTest contributors
 *
 * This file is part of SynTest Framework - SynTest Javascript.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRelationType = exports.RelationType = exports.getRelationName = void 0;
function getRelationName(type) {
    return Object.entries(RelationType).find(([, value]) => value === type)[0];
}
exports.getRelationName = getRelationName;
var RelationType;
(function (RelationType) {
    // special
    RelationType["Return"] = "L->R";
    RelationType["Call"] = "L(R)";
    RelationType["PrivateName"] = "#L";
    RelationType["ObjectProperty"] = "{L:R}";
    RelationType["ObjectMethod"] = "{L(R)}";
    RelationType["ClassProperty"] = "L{K:V}";
    RelationType["StaticClassProperty"] = "L{static K:V}";
    RelationType["ClassMethod"] = "L{R()}";
    RelationType["AsyncClassMethod"] = "L{async R()}";
    RelationType["StaticClassMethod"] = "L{static R()}";
    RelationType["StaticAsyncClassMethod"] = "L{static async R()}";
    RelationType["ClassConstructor"] = "L{constructor(R)}";
    RelationType["ClassGetter"] = "L{get R}";
    RelationType["ClassSetter"] = "L{set R}";
    RelationType["ArrayPattern"] = "[L]";
    RelationType["ObjectPattern"] = "{L}";
    RelationType["RestElement"] = "...R";
    RelationType["While"] = "while(L)";
    RelationType["If"] = "if(L)";
    RelationType["For"] = "for(L)";
    RelationType["ForIn"] = "for(L in R)";
    RelationType["ForOf"] = "for(L of R)";
    RelationType["Switch"] = "switch(L) case R";
    // Primary Expressions
    RelationType["This"] = "this";
    // literals are processed differently
    RelationType["ArrayInitializer"] = "[L]";
    RelationType["ObjectInitializer"] = "{L}";
    RelationType["ClassDefinition"] = "class L";
    RelationType["FunctionDefinition"] = "function L(R)";
    RelationType["FunctionStarDefinition"] = "function* L(R)";
    RelationType["AsyncFunctionDefinition"] = "async function L(R)";
    RelationType["AsyncFunctionStarDefinition"] = "async function* L(R)";
    // RegularExpression = "/L/", this is a literal
    RelationType["TemplateLiteral"] = "`L`";
    RelationType["Sequence"] = "(L,R)";
    // Left-hand-side Expressions
    RelationType["PropertyAccessor"] = "L.R";
    RelationType["OptionalPropertyAccessor"] = "L?.R";
    RelationType["New"] = "new L()";
    // TODO new.target
    // TODO import.meta
    // TODO super()
    // TODO import()
    // UNARY
    // Increment and Decrement
    RelationType["PlusPlusPostFix"] = "L++";
    RelationType["MinusMinusPostFix"] = "L--";
    RelationType["PlusPlusPrefix"] = "++L";
    RelationType["MinusMinusPrefix"] = "--L";
    // Unary
    RelationType["Delete"] = "delete L";
    RelationType["Void"] = "void L";
    RelationType["TypeOf"] = "typeof L";
    RelationType["PlusUnary"] = "+L";
    RelationType["MinusUnary"] = "-L";
    RelationType["BitwiseNotUnary"] = "~L";
    RelationType["LogicalNotUnary"] = "!L";
    RelationType["Await"] = "await L";
    // BINARY
    // Arithmetic
    RelationType["Addition"] = "L+R";
    RelationType["Subtraction"] = "L-R";
    RelationType["Division"] = "L/R";
    RelationType["Multiplication"] = "L*R";
    RelationType["Remainder"] = "L%R";
    RelationType["Exponentiation"] = "L**R";
    // Relation
    RelationType["Less"] = "L<R";
    RelationType["Greater"] = "L>R";
    RelationType["LessOrEqual"] = "L<=R";
    RelationType["GreaterOrEqual"] = "L>=R";
    RelationType["InstanceOf"] = "L instanceof R";
    RelationType["In"] = "L in R";
    // Equality
    RelationType["Equality"] = "L==R";
    RelationType["InEquality"] = "L!=R";
    RelationType["StrictEquality"] = "L===R";
    RelationType["StrictInequality"] = "L!==R";
    // Bitwise shift
    RelationType["BitwiseLeftShift"] = "L<<R";
    RelationType["BitwiseRightShift"] = "L>>R";
    RelationType["BitwiseUnsignedRightShift"] = "L>>>R";
    // Binary bitwise
    RelationType["BitwiseAnd"] = "L&R";
    RelationType["BitwiseOr"] = "L|R";
    RelationType["BitwiseXor"] = "L^R";
    // Binary logical
    RelationType["LogicalAnd"] = "L&&R";
    RelationType["LogicalOr"] = "L||R";
    RelationType["NullishCoalescing"] = "L??R";
    // Ternary
    RelationType["Conditional"] = "C?L:R";
    // Assignment
    RelationType["Assignment"] = "L=R";
    RelationType["MultiplicationAssignment"] = "L*=R";
    RelationType["ExponentiationAssignment"] = "L**=R";
    RelationType["DivisionAssignment"] = "L/=R";
    RelationType["RemainderAssigment"] = "L%=R";
    RelationType["AdditionAssignment"] = "L+=R";
    RelationType["SubtractionAssignment"] = "L-=R";
    RelationType["LeftShiftAssignment"] = "L<<=R";
    RelationType["RightShiftAssignment"] = "L>>=R";
    RelationType["UnSignedRightShiftAssignment"] = "L>>>=R";
    RelationType["BitwiseAndAssignment"] = "L&=R";
    RelationType["BitwiseXorAssignment"] = "L^=R";
    RelationType["BitwiseOrAssignment"] = "L|=R";
    RelationType["LogicalAndAssignment"] = "L&&=R";
    RelationType["LogicalOrAssignment"] = "L||=R";
    RelationType["LogicalNullishAssignment"] = "L??=R";
    // destructuring assignment is equal to assignment
    // yield
    RelationType["Yield"] = "yield L";
    RelationType["YieldStar"] = "yield* L";
    // spread
    RelationType["Spread"] = "...L";
    // comma
    RelationType["Comma"] = "L,R";
})(RelationType = exports.RelationType || (exports.RelationType = {}));
function getUnaryRelationType(operator, prefix) {
    switch (operator) {
        case "++": {
            return prefix
                ? RelationType.PlusPlusPrefix
                : RelationType.PlusPlusPostFix;
        }
        case "--": {
            return prefix
                ? RelationType.MinusMinusPrefix
                : RelationType.MinusMinusPostFix;
        }
        case "delete": {
            return RelationType.Delete;
        }
        case "void": {
            return RelationType.Void;
        }
        case "typeof": {
            return RelationType.TypeOf;
        }
        case "+": {
            return RelationType.PlusUnary;
        }
        case "-": {
            return RelationType.MinusUnary;
        }
        case "~": {
            return RelationType.BitwiseNotUnary;
        }
        case "!": {
            return RelationType.LogicalNotUnary;
        }
        case "await": {
            return RelationType.Await;
        }
    }
    throw new Error(`Unsupported relation type operator: unary -> ${operator}`);
}
function getBinaryRelationType(operator) {
    switch (operator) {
        case "+": {
            return RelationType.Addition;
        }
        case "-": {
            return RelationType.Subtraction;
        }
        case "/": {
            return RelationType.Division;
        }
        case "*": {
            return RelationType.Multiplication;
        }
        case "%": {
            return RelationType.Remainder;
        }
        case "**": {
            return RelationType.Exponentiation;
        }
        case "<": {
            return RelationType.Less;
        }
        case ">": {
            return RelationType.Greater;
        }
        case "<=": {
            return RelationType.LessOrEqual;
        }
        case ">=": {
            return RelationType.GreaterOrEqual;
        }
        case "instanceof": {
            return RelationType.InstanceOf;
        }
        case "in": {
            return RelationType.In;
        }
        case "==": {
            return RelationType.Equality;
        }
        case "!=": {
            return RelationType.InEquality;
        }
        case "===": {
            return RelationType.StrictEquality;
        }
        case "!==": {
            return RelationType.StrictInequality;
        }
        case "<<": {
            return RelationType.BitwiseLeftShift;
        }
        case ">>": {
            return RelationType.BitwiseRightShift;
        }
        case ">>>": {
            return RelationType.BitwiseUnsignedRightShift;
        }
        case "&": {
            return RelationType.BitwiseAnd;
        }
        case "|": {
            return RelationType.BitwiseOr;
        }
        case "^": {
            return RelationType.BitwiseXor;
        }
        case "&&": {
            return RelationType.LogicalAnd;
        }
        case "||": {
            return RelationType.LogicalAnd;
        }
        case "??": {
            return RelationType.NullishCoalescing;
        }
    }
    throw new Error(`Unsupported relation type operator: binary -> ${operator}`);
}
function getAssignmentRelationType(operator) {
    switch (operator) {
        case "=": {
            return RelationType.Assignment;
        }
        case "*=": {
            return RelationType.MultiplicationAssignment;
        }
        case "**=": {
            return RelationType.ExponentiationAssignment;
        }
        case "/=": {
            return RelationType.DivisionAssignment;
        }
        case "%=": {
            return RelationType.RemainderAssigment;
        }
        case "+=": {
            return RelationType.AdditionAssignment;
        }
        case "-=": {
            return RelationType.SubtractionAssignment;
        }
        case "<<=": {
            return RelationType.LeftShiftAssignment;
        }
        case ">>=": {
            return RelationType.RightShiftAssignment;
        }
        case ">>>=": {
            return RelationType.UnSignedRightShiftAssignment;
        }
        case "&=": {
            return RelationType.BitwiseAndAssignment;
        }
        case "^=": {
            return RelationType.BitwiseXorAssignment;
        }
        case "|=": {
            return RelationType.BitwiseOrAssignment;
        }
        case "&&=": {
            return RelationType.LogicalAndAssignment;
        }
        case "||=": {
            return RelationType.LogicalOrAssignment;
        }
        case "??=": {
            return RelationType.LogicalNullishAssignment;
        }
    }
    throw new Error(`Unsupported relation type operator: assignment -> ${operator}`);
}
function getRelationType(type, operator, prefix = false) {
    switch (type) {
        case "unary": {
            return getUnaryRelationType(operator, prefix);
        }
        case "binary": {
            return getBinaryRelationType(operator);
        }
        case "assignment": {
            return getAssignmentRelationType(operator);
        }
    }
    throw new Error(`Unsupported relation type operator: ${type} -> ${operator}`);
}
exports.getRelationType = getRelationType;
//# sourceMappingURL=Relation.js.map