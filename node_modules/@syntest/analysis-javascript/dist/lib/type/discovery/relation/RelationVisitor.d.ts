import { NodePath } from "@babel/core";
import * as t from "@babel/types";
import { AbstractSyntaxTreeVisitor } from "@syntest/ast-visitor-javascript";
import { Relation } from "../relation/Relation";
export declare class RelationVisitor extends AbstractSyntaxTreeVisitor {
    private _relationMap;
    get relationMap(): Map<string, Relation>;
    constructor(filePath: string, syntaxForgiving: boolean);
    private _createRelation;
    ReturnStatement: (path: NodePath<t.ReturnStatement>) => void;
    CallExpression: (path: NodePath<t.CallExpression>) => void;
    PrivateName: (path: NodePath<t.PrivateName>) => void;
    ObjectProperty: (path: NodePath<t.ObjectProperty>) => void;
    ObjectMethod: (path: NodePath<t.ObjectMethod>) => void;
    ClassProperty: (path: NodePath<t.ClassProperty>) => void;
    ClassMethod: (path: NodePath<t.ClassMethod>) => void;
    ArrayPattern: (path: NodePath<t.ArrayPattern>) => void;
    ObjectPattern: (path: NodePath<t.ObjectPattern>) => void;
    RestElement: (path: NodePath<t.RestElement>) => void;
    ThisExpression: (path: NodePath<t.ThisExpression>) => void;
    ArrayExpression: (path: NodePath<t.ArrayExpression>) => void;
    ObjectExpression: (path: NodePath<t.ObjectExpression>) => void;
    FunctionExpression: (path: NodePath<t.FunctionExpression>) => void;
    FunctionDeclaration: (path: NodePath<t.FunctionDeclaration>) => void;
    ArrowFunctionExpression: (path: NodePath<t.ArrowFunctionExpression>) => void;
    ClassExpression: (path: NodePath<t.ClassExpression>) => void;
    ClassDeclaration: (path: NodePath<t.ClassDeclaration>) => void;
    TemplateLiteral: (path: NodePath<t.TemplateLiteral>) => void;
    SequenceExpression: (path: NodePath<t.SequenceExpression>) => void;
    MemberExpression: (path: NodePath<t.MemberExpression>) => void;
    OptionalMemberExpression: (path: NodePath<t.OptionalMemberExpression>) => void;
    MetaProperty: (path: NodePath<t.MetaProperty>) => void;
    NewExpression: (path: NodePath<t.NewExpression>) => void;
    UpdateExpression: (path: NodePath<t.UpdateExpression>) => void;
    UnaryExpression: (path: NodePath<t.UnaryExpression>) => void;
    AwaitExpression: (path: NodePath<t.AwaitExpression>) => void;
    BinaryExpression: (path: NodePath<t.BinaryExpression>) => void;
    LogicalExpression: (path: NodePath<t.LogicalExpression>) => void;
    ConditionalExpression: (path: NodePath<t.ConditionalExpression>) => void;
    AssignmentExpression: (path: NodePath<t.AssignmentExpression>) => void;
    AssignmentPattern: (path: NodePath<t.AssignmentPattern>) => void;
    VariableDeclarator: (path: NodePath<t.VariableDeclarator>) => void;
    SpreadElement: (path: NodePath<t.SpreadElement>) => void;
    WhileStatement: (path: NodePath<t.WhileStatement>) => void;
    IfStatement: (path: NodePath<t.IfStatement>) => void;
    ForStatement: (path: NodePath<t.ForStatement>) => void;
    ForInStatement: (path: NodePath<t.ForInStatement>) => void;
    ForOfStatement: (path: NodePath<t.ForOfStatement>) => void;
    SwitchStatement: (path: NodePath<t.SwitchStatement>) => void;
}
//# sourceMappingURL=RelationVisitor.d.ts.map