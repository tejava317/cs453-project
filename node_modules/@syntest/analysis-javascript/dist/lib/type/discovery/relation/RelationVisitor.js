"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RelationVisitor = void 0;
const ast_visitor_javascript_1 = require("@syntest/ast-visitor-javascript");
const Relation_1 = require("../relation/Relation");
class RelationVisitor extends ast_visitor_javascript_1.AbstractSyntaxTreeVisitor {
    get relationMap() {
        return this._relationMap;
    }
    constructor(filePath, syntaxForgiving) {
        super(filePath, syntaxForgiving);
        // special
        this.ReturnStatement = (path) => {
            const type = Relation_1.RelationType.Return;
            // get the function id
            const functionPath = path.findParent((p) => p.isFunction());
            if (functionPath === null) {
                // should not be possible
                throw new Error("Return statement is not inside a function");
            }
            if (path.has("argument")) {
                this._createRelation(path, type, [functionPath, path.get("argument")]);
            }
            else {
                this._createRelation(path, type, [functionPath]);
            }
        };
        this.CallExpression = (path) => {
            const type = Relation_1.RelationType.Call;
            this._createRelation(path, type, [
                path.get("callee"),
                ...path.get("arguments"),
            ]);
        };
        this.PrivateName = (path) => {
            const type = Relation_1.RelationType.PrivateName;
            this._createRelation(path, type, [path.get("id")]);
        };
        this.ObjectProperty = (path) => {
            const type = Relation_1.RelationType.ObjectProperty;
            this._createRelation(path, type, [path.get("key"), path.get("value")], path.node.computed);
        };
        this.ObjectMethod = (path) => {
            const type = Relation_1.RelationType.ObjectMethod;
            this._createRelation(path, type, [path.get("key"), ...path.get("params")], path.node.computed);
        };
        this.ClassProperty = (path) => {
            const classParent = path.findParent((p) => p.isClass());
            const involved = [classParent, path];
            if (path.has("value")) {
                involved.push(path.get("value"));
            }
            if (path.node.static) {
                this._createRelation(path, Relation_1.RelationType.StaticClassProperty, involved, path.node.computed);
            }
            else {
                this._createRelation(path, Relation_1.RelationType.ClassProperty, involved, path.node.computed);
            }
        };
        this.ClassMethod = (path) => {
            const classParent = path.findParent((p) => p.isClass());
            switch (path.node.kind) {
                case "constructor": {
                    this._createRelation(path, Relation_1.RelationType.ClassConstructor, [classParent, path, ...path.get("params")], path.node.computed);
                    break;
                }
                case "get": {
                    this._createRelation(path, Relation_1.RelationType.ClassGetter, [classParent, path], path.node.computed);
                    break;
                }
                case "set": {
                    this._createRelation(path, Relation_1.RelationType.ClassSetter, [classParent, path, ...path.get("params")], path.node.computed);
                    break;
                }
                default: {
                    if (path.node.static && path.node.async) {
                        this._createRelation(path, Relation_1.RelationType.StaticAsyncClassMethod, [classParent, path, ...path.get("params")], path.node.computed);
                    }
                    else if (path.node.static) {
                        this._createRelation(path, Relation_1.RelationType.StaticClassMethod, [classParent, path, ...path.get("params")], path.node.computed);
                    }
                    else if (path.node.async) {
                        this._createRelation(path, Relation_1.RelationType.AsyncClassMethod, [classParent, path, ...path.get("params")], path.node.computed);
                    }
                    else {
                        this._createRelation(path, Relation_1.RelationType.ClassMethod, [classParent, path, ...path.get("params")], path.node.computed);
                    }
                }
            }
        };
        this.ArrayPattern = (path) => {
            const type = Relation_1.RelationType.ArrayPattern;
            if (path.has("elements")) {
                this._createRelation(path, type, path.get("elements").filter((p) => p.node !== null));
            }
            else {
                this._createRelation(path, type, []);
            }
        };
        this.ObjectPattern = (path) => {
            const type = Relation_1.RelationType.ObjectPattern;
            if (path.has("properties")) {
                this._createRelation(path, type, path.get("properties"));
            }
            else {
                this._createRelation(path, type, []);
            }
        };
        this.RestElement = (path) => {
            const type = Relation_1.RelationType.RestElement;
            this._createRelation(path, type, [path.get("argument")]);
        };
        // primary expression
        this.ThisExpression = (path) => {
            const type = Relation_1.RelationType.This;
            const parent = this._getThisParent(path);
            if (parent) {
                this._createRelation(path, type, [parent]);
            }
        };
        this.ArrayExpression = (path) => {
            const type = Relation_1.RelationType.ArrayInitializer;
            if (path.has("elements")) {
                this._createRelation(path, type, path.get("elements").filter((p) => p.node !== null));
            }
            else {
                this._createRelation(path, type, []);
            }
        };
        this.ObjectExpression = (path) => {
            const type = Relation_1.RelationType.ObjectInitializer;
            if (path.has("properties")) {
                this._createRelation(path, type, path.get("properties"));
            }
            else {
                this._createRelation(path, type, []);
            }
        };
        this.FunctionExpression = (path) => {
            const id = path.has("id") ? path.get("id") : path;
            const involved = [id, ...path.get("params")];
            if (path.node.generator && path.node.async) {
                this._createRelation(path, Relation_1.RelationType.AsyncFunctionStarDefinition, involved);
            }
            else if (path.node.generator) {
                this._createRelation(path, Relation_1.RelationType.FunctionStarDefinition, involved);
            }
            else if (path.node.async) {
                this._createRelation(path, Relation_1.RelationType.AsyncFunctionDefinition, involved);
            }
            else {
                this._createRelation(path, Relation_1.RelationType.FunctionDefinition, involved);
            }
        };
        this.FunctionDeclaration = (path) => {
            const id = path.has("id") ? path.get("id") : path;
            if (path.node.generator && path.node.async) {
                this._createRelation(path, Relation_1.RelationType.AsyncFunctionStarDefinition, [
                    id,
                    ...path.get("params"),
                ]);
            }
            else if (path.node.generator) {
                this._createRelation(path, Relation_1.RelationType.FunctionStarDefinition, [
                    id,
                    ...path.get("params"),
                ]);
            }
            else if (path.node.async) {
                this._createRelation(path, Relation_1.RelationType.AsyncFunctionDefinition, [
                    id,
                    ...path.get("params"),
                ]);
            }
            else {
                this._createRelation(path, Relation_1.RelationType.FunctionDefinition, [
                    id,
                    ...path.get("params"),
                ]);
            }
        };
        this.ArrowFunctionExpression = (path) => {
            const type = Relation_1.RelationType.FunctionDefinition;
            // no id for arrow functions
            if (path.parentPath.isVariableDeclarator()) {
                this._createRelation(path, type, [
                    path.parentPath,
                    ...path.get("params"),
                ]);
            }
            else {
                this._createRelation(path, type, [path, ...path.get("params")]);
            }
        };
        this.ClassExpression = (path) => {
            const type = Relation_1.RelationType.ClassDefinition;
            this._createRelation(path, type, [path.get("id")]);
        };
        this.ClassDeclaration = (path) => {
            const type = Relation_1.RelationType.ClassDefinition;
            this._createRelation(path, type, [path.get("id")]);
        };
        this.TemplateLiteral = (path) => {
            const type = Relation_1.RelationType.TemplateLiteral;
            this._createRelation(path, type, [
                ...path.get("quasis"),
                ...path.get("expressions"),
            ]);
        };
        this.SequenceExpression = (path) => {
            const type = Relation_1.RelationType.Sequence;
            this._createRelation(path, type, path.get("expressions"));
        };
        // left-hand-side expression
        this.MemberExpression = (path) => {
            const type = Relation_1.RelationType.PropertyAccessor;
            this._createRelation(path, type, [path.get("object"), path.get("property")], path.node.computed);
        };
        this.OptionalMemberExpression = (path) => {
            const type = Relation_1.RelationType.OptionalPropertyAccessor;
            this._createRelation(path, type, [path.get("object"), path.get("property")], path.node.computed);
        };
        this.MetaProperty = (path) => {
            const type = Relation_1.RelationType.PropertyAccessor;
            this._createRelation(path, type, [path.get("meta"), path.get("property")]);
        };
        this.NewExpression = (path) => {
            const type = Relation_1.RelationType.New;
            this._createRelation(path, type, [
                path.get("callee"),
                ...path.get("arguments"),
            ]);
        };
        // UNARY
        // increment and decrement
        this.UpdateExpression = (path) => {
            const type = (0, Relation_1.getRelationType)("unary", path.node.operator, path.node.prefix);
            this._createRelation(path, type, [path.get("argument")]);
        };
        // unary
        this.UnaryExpression = (path) => {
            const type = (0, Relation_1.getRelationType)("unary", path.node.operator, path.node.prefix);
            this._createRelation(path, type, [path.get("argument")]);
        };
        this.AwaitExpression = (path) => {
            const type = Relation_1.RelationType.Await;
            this._createRelation(path, type, [path.get("argument")]);
        };
        // binary
        this.BinaryExpression = (path) => {
            const type = (0, Relation_1.getRelationType)("binary", path.node.operator);
            this._createRelation(path, type, [path.get("left"), path.get("right")]);
        };
        this.LogicalExpression = (path) => {
            const type = (0, Relation_1.getRelationType)("binary", path.node.operator);
            this._createRelation(path, type, [path.get("left"), path.get("right")]);
        };
        // ternary
        this.ConditionalExpression = (path) => {
            const type = Relation_1.RelationType.Conditional;
            this._createRelation(path, type, [
                path.get("test"),
                path.get("consequent"),
                path.get("alternate"),
            ]);
        };
        // assignment
        this.AssignmentExpression = (path) => {
            const type = (0, Relation_1.getRelationType)("assignment", path.node.operator);
            this._createRelation(path, type, [path.get("left"), path.get("right")]);
        };
        this.AssignmentPattern = (path) => {
            const type = Relation_1.RelationType.Assignment;
            this._createRelation(path, type, [path.get("left"), path.get("right")]);
        };
        this.VariableDeclarator = (path) => {
            if (path.has("init")) {
                const type = Relation_1.RelationType.Assignment;
                this._createRelation(path, type, [path.get("id"), path.get("init")]);
            }
            // if there is no init, it is a declaration
            // declarations are handled by the ElementVisitor
        };
        // TODO yield
        // spread
        this.SpreadElement = (path) => {
            const type = Relation_1.RelationType.Spread;
            this._createRelation(path, type, [path.get("argument")]);
        };
        // TODO comma
        this.WhileStatement = (path) => {
            const type = Relation_1.RelationType.While;
            this._createRelation(path, type, [path.get("test")]);
        };
        this.IfStatement = (path) => {
            const type = Relation_1.RelationType.If;
            this._createRelation(path, type, [path.get("test")]);
        };
        this.ForStatement = (path) => {
            const type = Relation_1.RelationType.For;
            if (path.has("test")) {
                this._createRelation(path, type, [path.get("test")]);
            }
            else {
                this._createRelation(path, type, []);
            }
        };
        this.ForInStatement = (path) => {
            const type = Relation_1.RelationType.ForIn;
            this._createRelation(path, type, [path.get("left"), path.get("right")]);
        };
        this.ForOfStatement = (path) => {
            const type = Relation_1.RelationType.ForIn;
            this._createRelation(path, type, [path.get("left"), path.get("right")]);
        };
        this.SwitchStatement = (path) => {
            const type = Relation_1.RelationType.Switch;
            this._createRelation(path, type, [
                path.get("discriminant"),
                ...path
                    .get("cases")
                    .filter((p) => p.has("test"))
                    .map((p) => p.get("test")),
            ]);
        };
        this._relationMap = new Map();
    }
    _createRelation(path, type, involved, computed = false) {
        const id = this._getNodeId(path);
        const relation = {
            id: id,
            type: type,
            involved: involved.map((p) => {
                if (p === undefined ||
                    p === null ||
                    p.node === null ||
                    p.node === undefined) {
                    throw new Error(`Involved node is undefined or null for ${id}`);
                    // return `${id}::anonymous`; // TODO we should look into this
                }
                return this._getNodeId(p);
            }),
            computed,
        };
        this._relationMap.set(relation.id, relation);
    }
}
exports.RelationVisitor = RelationVisitor;
//# sourceMappingURL=RelationVisitor.js.map