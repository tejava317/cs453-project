"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ElementVisitor = void 0;
const ast_visitor_javascript_1 = require("@syntest/ast-visitor-javascript");
const Element_1 = require("../element/Element");
class ElementVisitor extends ast_visitor_javascript_1.AbstractSyntaxTreeVisitor {
    get elementMap() {
        for (const value of this._elementMap.values()) {
            if (!this._elementMap.has(value.bindingId) &&
                value.bindingId.includes(ast_visitor_javascript_1.MemberSeparator)) {
                this._elementMap.set(value.bindingId, {
                    ...value,
                    id: value.bindingId,
                });
            }
        }
        return this._elementMap;
    }
    constructor(filePath, syntaxForgiving) {
        super(filePath, syntaxForgiving);
        this.Identifier = (path) => {
            if (path.node.name === "undefined") {
                this._createElement(path, Element_1.ElementType.Undefined, "undefined");
            }
            else {
                if (path.parentPath.isLabeledStatement() ||
                    path.parentPath.isContinueStatement() ||
                    path.parentPath.isBreakStatement()) {
                    // we ignore these types of identifiers
                    // these all have a label property, but we don't want to add them to the element map
                    return;
                }
                this._createElement(path, Element_1.ElementType.Identifier, path.node.name);
            }
        };
        this.Literal = (path) => {
            switch (path.node.type) {
                case "StringLiteral": {
                    this._createElement(path, Element_1.ElementType.StringLiteral, path.node.value);
                    break;
                }
                case "NumericLiteral": {
                    this._createElement(path, Element_1.ElementType.NumericalLiteral, path.node.value.toString());
                    break;
                }
                case "NullLiteral": {
                    this._createElement(path, Element_1.ElementType.NullLiteral, "null");
                    break;
                }
                case "BooleanLiteral": {
                    this._createElement(path, Element_1.ElementType.BooleanLiteral, path.node.value.toString());
                    break;
                }
                case "RegExpLiteral": {
                    this._createElement(path, Element_1.ElementType.RegExpLiteral, path.node.pattern);
                    break;
                }
                case "TemplateLiteral": {
                    // we handle template literals as relations
                    break;
                }
                case "BigIntLiteral": {
                    this._createElement(path, Element_1.ElementType.BigIntLiteral, path.node.value.toString());
                    break;
                }
                case "DecimalLiteral": {
                    this._createElement(path, Element_1.ElementType.DecimalLiteral, path.node.value.toString());
                    break;
                }
                default: {
                    // should never occur
                    throw new Error(`Unknown literal type`);
                }
            }
        };
        this.TemplateElement = (path) => {
            this._createElement(path, Element_1.ElementType.StringLiteral, path.node.value.raw);
        };
        this._elementMap = new Map();
    }
    _createElement(path, type, value) {
        const id = this._getNodeId(path);
        const bindingId = this._getBindingId(path);
        // Here we check if the id is already registered (we do not allow this normally)
        if (this._elementMap.has(id)) {
            // Export specifiers can actually have the same exported and local object
            // e.g. export { x }
            if (path.parentPath.isExportSpecifier() &&
                path.parentPath.get("exported") === path) {
                return;
            }
            // Import specifiers can actually have the same imported and local object
            // e.g. import { x } from '...'
            if (path.parentPath.isImportSpecifier() &&
                path.parentPath.get("imported") === path) {
                return;
            }
            // Object properties can actually have the same value and key object
            // e.g. const obj = { x }
            if (path.parentPath.isObjectProperty() &&
                path.parentPath.get("value") === path) {
                return;
            }
            throw new Error(`Overriding element with id: ${id}`);
        }
        if (type === Element_1.ElementType.Identifier) {
            const element = {
                id: id,
                bindingId,
                filePath: this._filePath,
                location: {
                    startIndex: path.node.loc.start.index,
                    endIndex: path.node.loc.end.index,
                },
                type: Element_1.ElementType.Identifier,
                name: value,
            };
            this._elementMap.set(element.id, element);
        }
        else {
            const element = {
                id: id,
                bindingId,
                filePath: this._filePath,
                location: {
                    startIndex: path.node.loc.start.index,
                    endIndex: path.node.loc.end.index,
                },
                type,
                value,
            };
            this._elementMap.set(element.id, element);
        }
    }
}
exports.ElementVisitor = ElementVisitor;
//# sourceMappingURL=ElementVisitor.js.map