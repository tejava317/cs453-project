"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectVisitor = void 0;
const ast_visitor_javascript_1 = require("@syntest/ast-visitor-javascript");
const DiscoveredType_1 = require("./DiscoveredType");
class ObjectVisitor extends ast_visitor_javascript_1.AbstractSyntaxTreeVisitor {
    get objectTypeMap() {
        return this._objectTypeMap;
    }
    constructor(filePath, syntaxForgiving) {
        super(filePath, syntaxForgiving);
        // classes
        this.ClassExpression = (path) => {
            const complexType = {
                id: this._getNodeId(path),
                kind: DiscoveredType_1.DiscoveredObjectKind.CLASS,
                properties: new Map(),
            };
            this._objectTypeMap.set(this._getNodeId(path), complexType);
            this._objectStack.push(complexType);
            path.get("body").visit();
            this._removeFromStack(path);
            path.skip();
        };
        this.ClassDeclaration = (path) => {
            const complexType = {
                id: this._getNodeId(path),
                kind: DiscoveredType_1.DiscoveredObjectKind.CLASS,
                properties: new Map(),
            };
            this._objectTypeMap.set(this._getNodeId(path), complexType);
            this._objectStack.push(complexType);
            path.get("body").visit();
            this._removeFromStack(path);
            path.skip();
        };
        this.ClassMethod = (path) => {
            const name = this._getPropertyName(path.node.key);
            const currentObject = this._getCurrentObject(path);
            currentObject.properties.set(name, this._getNodeId(path));
        };
        this.ClassPrivateMethod = (path) => {
            const name = this._getPropertyName(path.node.key.id);
            const currentObject = this._getCurrentObject(path);
            currentObject.properties.set(`#${name}`, this._getNodeId(path));
        };
        this.ClassProperty = (path) => {
            const name = this._getPropertyName(path.node.key);
            const currentObject = this._getCurrentObject(path);
            currentObject.properties.set(name, this._getNodeId(path));
        };
        this.ClassPrivateProperty = (path) => {
            const name = this._getPropertyName(path.node.key.id);
            const currentObject = this._getCurrentObject(path);
            currentObject.properties.set(`#${name}`, this._getNodeId(path));
        };
        // TODO ClassAccessorProperty | TSDeclareMethod | TSIndexSignature | StaticBlock
        // TODO interfaces
        // public InterfaceDeclaration: (path: NodePath<t.InterfaceDeclaration>) => void = (
        //   path: NodePath<t.InterfaceDeclaration>
        // ) => {
        // };
        // Objects
        this.ObjectExpression = (path) => {
            const complexType = {
                id: this._getNodeId(path),
                kind: DiscoveredType_1.DiscoveredObjectKind.OBJECT,
                properties: new Map(),
            };
            this._objectTypeMap.set(this._getNodeId(path), complexType);
            this._objectStack.push(complexType);
            for (const property of path.get("properties")) {
                property.visit();
            }
            this._removeFromStack(path);
            path.skip();
        };
        this.ObjectPattern = (path) => {
            const complexType = {
                id: this._getNodeId(path),
                kind: DiscoveredType_1.DiscoveredObjectKind.OBJECT,
                properties: new Map(),
            };
            this._objectTypeMap.set(this._getNodeId(path), complexType);
            this._objectStack.push(complexType);
            for (const property of path.get("properties")) {
                property.visit();
            }
            this._removeFromStack(path);
            path.skip();
        };
        this.ObjectMethod = (path) => {
            const name = this._getPropertyName(path.node.key);
            const currentObject = this._getCurrentObject(path);
            currentObject.properties.set(name, this._getNodeId(path));
        };
        this.ObjectProperty = (path) => {
            const currentObject = this._getCurrentObject(path);
            if (path.node.computed) {
                ObjectVisitor.LOGGER.warn(`This tool does not support computed property assignments. Found one at ${this._getNodeId(path)}`);
                return;
            }
            if (path.node.key.type === "PrivateName") {
                const name = this._getPropertyName(path.node.key.id);
                currentObject.properties.set(`#${name}`, this._getNodeId(path));
            }
            else {
                const name = this._getPropertyName(path.node.key);
                currentObject.properties.set(name, this._getNodeId(path));
            }
        };
        // TODO SpreadElement
        // Functions
        this.FunctionDeclaration = (path) => {
            const complexType = {
                id: this._getNodeId(path),
                kind: DiscoveredType_1.DiscoveredObjectKind.FUNCTION,
                properties: new Map(),
            };
            this._objectTypeMap.set(this._getNodeId(path), complexType);
            this._objectStack.push(complexType);
            path.get("body").visit();
            this._removeFromStack(path);
            path.skip();
        };
        this.FunctionExpression = (path) => {
            const complexType = {
                id: this._getNodeId(path),
                kind: DiscoveredType_1.DiscoveredObjectKind.FUNCTION,
                properties: new Map(),
            };
            this._objectTypeMap.set(this._getNodeId(path), complexType);
            this._objectStack.push(complexType);
            path.get("body").visit();
            this._removeFromStack(path);
            path.skip();
        };
        this.ArrowFunctionExpression = (path) => {
            const complexType = {
                id: this._getNodeId(path),
                kind: DiscoveredType_1.DiscoveredObjectKind.FUNCTION,
                properties: new Map(),
            };
            this._objectTypeMap.set(this._getNodeId(path), complexType);
            this._objectStack.push(complexType);
            path.get("body").visit();
            this._removeFromStack(path);
            path.skip();
        };
        this.MemberExpression = (path) => {
            if (path.node.computed) {
                return;
            }
            if (path.node.object.type === "ThisExpression") {
                const parent = this._getThisParent(path);
                if (!parent) {
                    return;
                }
                const _object = this.objectTypeMap.get(this._getNodeId(parent));
                if (!_object) {
                    throw new Error(`Unexpected object type: ${path.node.object.type} at ${this._getNodeId(path)}`);
                }
                if (path.node.property.type === "PrivateName") {
                    const name = this._getPropertyName(path.node.property.id);
                    _object.properties.set(`#${name}`, this._getNodeId(path));
                }
                else {
                    const name = this._getPropertyName(path.node.property);
                    _object.properties.set(name, this._getNodeId(path));
                }
            }
            else if (path.node.object.type === "Identifier") {
                const bindingId = this._getBindingId(path.get("object"));
                let _object = this.objectTypeMap.get(bindingId);
                if (!_object) {
                    _object = {
                        id: bindingId,
                        kind: DiscoveredType_1.DiscoveredObjectKind.OBJECT,
                        properties: new Map(),
                    };
                    this._objectTypeMap.set(bindingId, _object);
                }
                if (path.node.property.type === "PrivateName") {
                    const name = this._getPropertyName(path.node.property.id);
                    _object.properties.set(`#${name}`, this._getNodeId(path));
                }
                else {
                    const name = this._getPropertyName(path.node.property);
                    _object.properties.set(name, this._getNodeId(path));
                }
            }
        };
        this._objectTypeMap = new Map();
        this._objectStack = [];
    }
    _getCurrentObject(path) {
        if (this._objectStack.length === 0) {
            throw new Error(`No current object found! Location: ${this._getNodeId(path)}`);
        }
        return this._objectStack[this._objectStack.length - 1];
    }
    _removeFromStack(path) {
        const currentObject = this._getCurrentObject(path);
        if (currentObject.id === this._getNodeId(path)) {
            this._objectStack.pop();
        }
        else {
            throw new Error(`Unexpected object stack state: ${currentObject.id} !== ${this._getNodeId(path)}`);
        }
    }
    _getPropertyName(node) {
        if (node.type === "Identifier") {
            // e.g. class A { x = class {} }
            // e.g. class A { x = function () {} }
            // e.g. class A { x = () => {} }
            return node.name;
        }
        else if (node.type.includes("Literal")) {
            // e.g. class A { "x" = class {} }
            // e.g. class A { "x" = function () {} }
            // e.g. class A { "x" = () => {} }
            return "value" in node ? node.value.toString() : "null";
        }
        else {
            // e.g. const {x} = class {}
            // e.g. const {x} = function {}
            // e.g. const {x} = () => {}
            // Should not be possible
            throw new Error(`Unexpected property name type: ${node.type} at ${this._getNodeId(node)}`);
        }
    }
}
exports.ObjectVisitor = ObjectVisitor;
//# sourceMappingURL=ObjectVisitor.js.map