"use strict";
/*
 * Copyright 2020-2023 Delft University of Technology and SynTest contributors
 *
 * This file is part of SynTest Framework - SynTest JavaScript.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypePool = void 0;
const prng_1 = require("@syntest/prng");
// TODO we could cache some of this stuff (unless we do dynamic adding of properties at some point)
class TypePool {
    constructor(objectMap, exports) {
        this._objectMap = objectMap;
        this._exports = exports;
        this._exportedObjects = this._extractExportedTypes();
    }
    _extractExportedTypes() {
        const exportedTypes = new Map();
        for (const [, exports] of this._exports.entries()) {
            for (const export_ of exports) {
                for (const objectMap of this._objectMap.values()) {
                    for (const [objectName, discoveredObject] of objectMap.entries()) {
                        if (discoveredObject.id === export_.id) {
                            exportedTypes.set(objectName, discoveredObject);
                        }
                    }
                }
            }
        }
        return exportedTypes;
    }
    _getMatchingTypes(objectType) {
        const matchingTypes = [];
        for (const object_ of this._exportedObjects.values()) {
            let match = true;
            for (const property of objectType.properties.keys()) {
                if (!object_.properties.has(property)) {
                    match = false;
                    break;
                }
            }
            if (match) {
                matchingTypes.push(object_);
            }
        }
        return matchingTypes;
    }
    getRandomMatchingType(objectType, extraFilter) {
        let matchingTypes = this._getMatchingTypes(objectType);
        if (extraFilter) {
            matchingTypes = matchingTypes.filter((type) => extraFilter(type));
        }
        if (matchingTypes.length === 0) {
            return undefined;
        }
        return prng_1.prng.pickOne(matchingTypes);
    }
}
exports.TypePool = TypePool;
//# sourceMappingURL=TypePool.js.map