"use strict";
/*
 * Copyright 2020-2023 Delft University of Technology and SynTest contributors
 *
 * This file is part of SynTest Framework - SynTest Javascript.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InferenceTypeModelFactory = void 0;
const Element_1 = require("../discovery/element/Element");
const Relation_1 = require("../discovery/relation/Relation");
const TypeEnum_1 = require("./TypeEnum");
const TypeModel_1 = require("./TypeModel");
const TypeModelFactory_1 = require("./TypeModelFactory");
class InferenceTypeModelFactory extends TypeModelFactory_1.TypeModelFactory {
    constructor() {
        super();
    }
    resolveTypes(elementMaps, relationMaps) {
        this._typeModel = new TypeModel_1.TypeModel();
        this._idToBindingIdMap = new Map();
        for (const filepath of elementMaps.keys()) {
            const elementMap = elementMaps.get(filepath);
            const relationMap = relationMaps.get(filepath);
            if (!elementMap || !relationMap) {
                throw new Error("Filepath should exist in both the element and relation map");
            }
            this.createLiteralTypeMaps(elementMap);
            this.createIdentifierTypeMaps(elementMap);
            this.createRelationTypeMaps(elementMap, relationMap);
            this.inferRelationTypes(elementMap, relationMap);
        }
        // TODO check for array/function/string type
        return this._typeModel;
    }
    createNewTypeProbability(id, bindingId) {
        this._typeModel.addId(bindingId);
        if (id === bindingId) {
            // don't set if the id and binding are equal
            return;
        }
        if (this._idToBindingIdMap.has(id) &&
            this._idToBindingIdMap.get(id) !== bindingId) {
            throw new Error(`Setting a new binding id to a previously set id is not allowed. Id: ${id}, old binding: ${this._idToBindingIdMap.get(id)}, new binding: ${bindingId}`);
        }
        this._idToBindingIdMap.set(id, bindingId);
        // always requires a mapping to itself
        // because for example a global variable is never declared
        // so we create a global::variable binding id
        // but this binding id is never created in the element map
        // so we manually add it here
        // if ()
        // this._idToBindingIdMap.set(bindingId, bindingId);
    }
    createLiteralTypeMaps(elementMap) {
        for (const element of elementMap.values()) {
            if (element.type === Element_1.ElementType.Identifier) {
                continue;
            }
            this.createNewTypeProbability(element.id, element.bindingId);
            this._typeModel.addTypeScore(element.bindingId, (0, TypeEnum_1.elementTypeToTypingType)(element.type));
        }
    }
    createIdentifierTypeMaps(elementMap) {
        for (const element of elementMap.values()) {
            if (element.type !== Element_1.ElementType.Identifier) {
                continue;
            }
            this.createNewTypeProbability(element.id, element.bindingId);
        }
    }
    createRelationTypeMaps(elementMap, relationMap) {
        for (const relation of relationMap.values()) {
            this.createNewTypeProbability(relation.id, relation.id);
            for (let index = 0; index < relation.involved.length; index++) {
                const involvedId = relation.involved[index];
                if (elementMap.has(involvedId)) {
                    const element = elementMap.get(involvedId);
                    if (element.type === Element_1.ElementType.Identifier) {
                        this.createNewTypeProbability(element.id, element.bindingId);
                    }
                    else {
                        this.createNewTypeProbability(element.id, element.id);
                    }
                }
                else {
                    // relation
                    this.createNewTypeProbability(involvedId, involvedId);
                }
            }
        }
    }
    inferRelationTypes(elementMap, relationMap) {
        const solveOrder = [
            Relation_1.RelationType.ClassDefinition,
            Relation_1.RelationType.ObjectPattern,
            Relation_1.RelationType.ArrayPattern,
            Relation_1.RelationType.ObjectInitializer,
            Relation_1.RelationType.ArrayInitializer,
            Relation_1.RelationType.FunctionDefinition,
            Relation_1.RelationType.FunctionStarDefinition,
            Relation_1.RelationType.AsyncFunctionDefinition,
            Relation_1.RelationType.AsyncFunctionStarDefinition,
            Relation_1.RelationType.ClassProperty,
            Relation_1.RelationType.StaticClassProperty,
            Relation_1.RelationType.ClassMethod,
            Relation_1.RelationType.AsyncClassMethod,
            Relation_1.RelationType.StaticClassMethod,
            Relation_1.RelationType.StaticAsyncClassMethod,
            Relation_1.RelationType.ClassConstructor,
            Relation_1.RelationType.ClassGetter,
            Relation_1.RelationType.ClassSetter,
            Relation_1.RelationType.ObjectMethod,
            Relation_1.RelationType.ObjectProperty,
            Relation_1.RelationType.Assignment,
            Relation_1.RelationType.Return,
            Relation_1.RelationType.Call,
            Relation_1.RelationType.PropertyAccessor,
            Relation_1.RelationType.OptionalPropertyAccessor,
        ];
        const sortedRelations = [...relationMap.values()].sort((a, b) => {
            const aIndex = solveOrder.indexOf(a.type);
            const bIndex = solveOrder.indexOf(b.type);
            if (aIndex === -1) {
                return 1;
            }
            else if (bIndex === -1) {
                return -1;
            }
            else {
                return aIndex - bIndex;
            }
        });
        for (const relation of sortedRelations) {
            this.resolveRelation(elementMap, relationMap, relation);
        }
    }
    resolveRelation(elementMap, relationMap, relation) {
        const relationId = relation.id;
        const relationType = relation.type;
        const originalInvolved = relation.involved;
        const involved = originalInvolved.map((id) => {
            while (this._idToBindingIdMap.has(id)) {
                id = this._idToBindingIdMap.get(id);
            }
            return id;
        });
        // eslint-disable-next-line sonarjs/max-switch-cases
        switch (relationType) {
            case Relation_1.RelationType.Return: {
                this._return(relation, involved);
                break;
            }
            case Relation_1.RelationType.Call: {
                this._call(relation, involved);
                break;
            }
            case Relation_1.RelationType.PrivateName: {
                // TODO
                break;
            }
            case Relation_1.RelationType.ObjectProperty: {
                this._objectProperty(elementMap, relation, involved);
                break;
            }
            case Relation_1.RelationType.ObjectMethod: {
                this._objectMethod(elementMap, relationMap, relation, involved);
                break;
            }
            case Relation_1.RelationType.ClassProperty:
            case Relation_1.RelationType.StaticClassProperty: {
                this._classProperty(elementMap, involved);
                break;
            }
            case Relation_1.RelationType.ClassMethod:
            case Relation_1.RelationType.AsyncClassMethod:
            case Relation_1.RelationType.StaticClassMethod:
            case Relation_1.RelationType.StaticAsyncClassMethod:
            case Relation_1.RelationType.ClassConstructor:
            case Relation_1.RelationType.ClassGetter:
            case Relation_1.RelationType.ClassSetter: {
                this._classMethod(elementMap, relationMap, involved);
                break;
            }
            case Relation_1.RelationType.ArrayPattern: {
                this._arrayPattern(relation, involved);
                break;
            }
            case Relation_1.RelationType.ObjectPattern: {
                // create object type
                // the properties are added through the ObjectMethod/ObjectProperty relations
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.OBJECT);
                break;
            }
            case Relation_1.RelationType.RestElement: {
                const restElement = involved[0];
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.ARRAY);
                // connect rest element to array
                this._typeModel.addStrongRelation(restElement, relationId);
                break;
            }
            case Relation_1.RelationType.While:
            case Relation_1.RelationType.If: {
                const conditionId = involved[0];
                // add boolean type to condition
                this._typeModel.addTypeScore(conditionId, TypeEnum_1.TypeEnum.BOOLEAN);
                break;
            }
            case Relation_1.RelationType.For: {
                this._for(involved);
                break;
            }
            case Relation_1.RelationType.ForIn: {
                this._forIn(involved);
                break;
            }
            case Relation_1.RelationType.ForOf: {
                this._forOf(involved);
                break;
            }
            case Relation_1.RelationType.Switch: {
                this._switch(involved);
                break;
            }
            // Primary Expressions
            case Relation_1.RelationType.This: {
                const thisParent = involved[0];
                // add this type to parent
                this._typeModel.addStrongRelation(thisParent, relationId);
                // create object type
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.OBJECT);
                break;
            }
            case Relation_1.RelationType.ArrayInitializer: {
                const elements = involved;
                // create array type
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.ARRAY);
                for (const id of elements) {
                    this._typeModel.addElementType(relationId, id);
                }
                break;
            }
            case Relation_1.RelationType.ObjectInitializer: {
                // create object type
                // the properties are added through the ObjectMethod/ObjectProperty relations
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.OBJECT);
                break;
            }
            case Relation_1.RelationType.ClassDefinition: {
                if (involved.length === 0) {
                    throw new Error(`Class definition has no involved elements`);
                }
                const classId = involved[0];
                // the properties are added through the ObjectMethod/ObjectProperty relations
                this._typeModel.addTypeScore(classId, TypeEnum_1.TypeEnum.OBJECT);
                // connect class to relation
                this._typeModel.setEqual(classId, relationId);
                // this._typeModel.addStrongRelation(relationId, classId);
                break;
            }
            case Relation_1.RelationType.FunctionDefinition:
            case Relation_1.RelationType.FunctionStarDefinition:
            case Relation_1.RelationType.AsyncFunctionDefinition:
            case Relation_1.RelationType.AsyncFunctionStarDefinition: {
                if (involved.length === 0) {
                    throw new Error(`Function definition has no involved elements`);
                }
                const functionId = relationId;
                const [identifierId, ...parameters] = involved;
                this.addFunctionParameters(elementMap, relationMap, functionId, parameters);
                // connect function to identifier
                this._typeModel.setEqual(functionId, identifierId);
                break;
            }
            case Relation_1.RelationType.TemplateLiteral: {
                // TODO something with the quasis and expressions
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.STRING);
                break;
            }
            case Relation_1.RelationType.Sequence: {
                // TODO nothing i think
                break;
            }
            // Left-hand-side Expressions
            case Relation_1.RelationType.PropertyAccessor:
            case Relation_1.RelationType.OptionalPropertyAccessor: {
                this._propertyAccessor(elementMap, relation, involved, originalInvolved);
                break;
            }
            case Relation_1.RelationType.New: {
                const class_ = involved[0];
                // TODO maybe this is not neccessary since the class is already connected to the relation
                // this._typeModel.addObjectTypeScore(relationId, {
                //   type: TypeEnum.OBJECT,
                //   properties: new Map()
                // });
                this._typeModel.addStrongRelation(relationId, class_);
                break;
            }
            case Relation_1.RelationType.PlusPlusPrefix: // must be numerical
            case Relation_1.RelationType.MinusMinusPrefix: // must be numerical
            case Relation_1.RelationType.PlusPlusPostFix: // must be numerical
            case Relation_1.RelationType.MinusMinusPostFix: {
                // must be numerical
                const argumentId = involved[0];
                this._typeModel.addTypeScore(argumentId, TypeEnum_1.TypeEnum.NUMERIC);
                this._typeModel.addWeakRelation(relationId, argumentId);
                break;
            }
            // Unary
            case Relation_1.RelationType.Delete: {
                // TODO can we say something about the argument?
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.UNDEFINED);
                break;
            }
            case Relation_1.RelationType.Void: {
                // TODO can we say something about the argument?
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.UNDEFINED);
                break;
            }
            case Relation_1.RelationType.TypeOf: {
                // TODO can we say something about the argument?
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.STRING);
                break;
            }
            case Relation_1.RelationType.PlusUnary:
            case Relation_1.RelationType.MinusUnary:
            case Relation_1.RelationType.BitwiseNotUnary: {
                // could be multiple things but the argument is probably numerical
                const argumentId = involved[0];
                this._typeModel.addTypeScore(argumentId, TypeEnum_1.TypeEnum.NUMERIC);
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.NUMERIC);
                break;
            }
            case Relation_1.RelationType.LogicalNotUnary: {
                // TODO can we say something about the argument?
                //likely also boolean?
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.BOOLEAN);
                break;
            }
            case Relation_1.RelationType.Await: {
                // often function?
                const argumentId = involved[0];
                this._typeModel.addTypeScore(argumentId, TypeEnum_1.TypeEnum.FUNCTION);
                const type_ = this._typeModel.getObjectDescription(argumentId);
                for (const returnType of type_.return) {
                    this._typeModel.addWeakRelation(relationId, returnType);
                }
                break;
            }
            // binary
            case Relation_1.RelationType.Addition: {
                if (involved.length !== 2) {
                    throw new Error(`Addition relation has wrong involved elements`);
                }
                const [leftId, rightId] = involved;
                // can be multiple things but string and number are the most likely
                this._typeModel.addTypeScore(leftId, TypeEnum_1.TypeEnum.NUMERIC);
                this._typeModel.addTypeScore(rightId, TypeEnum_1.TypeEnum.NUMERIC);
                this._typeModel.addTypeScore(leftId, TypeEnum_1.TypeEnum.STRING);
                this._typeModel.addTypeScore(rightId, TypeEnum_1.TypeEnum.STRING);
                this._typeModel.addWeakRelation(relationId, leftId);
                this._typeModel.addWeakRelation(relationId, rightId);
                // even though we add the relations we still add the number type directly since it is most likely
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.NUMERIC);
                break;
            }
            case Relation_1.RelationType.Subtraction: // must be numerical
            case Relation_1.RelationType.Division: // must be numerical
            case Relation_1.RelationType.Multiplication: // must be numerical
            case Relation_1.RelationType.Remainder: // must be numerical
            case Relation_1.RelationType.Exponentiation: {
                if (involved.length !== 2) {
                    throw new Error(`Relation has wrong involved elements`);
                }
                const [leftId, rightId] = involved;
                // can be multiple things but number is the most likely
                this._typeModel.addTypeScore(leftId, TypeEnum_1.TypeEnum.NUMERIC);
                this._typeModel.addTypeScore(rightId, TypeEnum_1.TypeEnum.NUMERIC);
                this._typeModel.addWeakRelation(relationId, leftId);
                this._typeModel.addWeakRelation(relationId, rightId);
                // even though we add the relations we still add the number type directly since it is most likely
                // in this case we are pretty sure the result is numeric so we give 2 score
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.NUMERIC, 2);
                break;
            }
            case Relation_1.RelationType.In: {
                const [, rightId] = involved;
                // right is likely an array or object
                this._typeModel.addTypeScore(rightId, TypeEnum_1.TypeEnum.ARRAY);
                this._typeModel.addTypeScore(rightId, TypeEnum_1.TypeEnum.OBJECT);
                // TODO
                // if it is an array we know the leftId is an element of the array
                // if it is an object we know the leftId is a property of the object
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.BOOLEAN);
                break;
            }
            case Relation_1.RelationType.InstanceOf: {
                const [leftId, rightId] = involved;
                this._typeModel.addTypeScore(leftId, TypeEnum_1.TypeEnum.OBJECT);
                this._typeModel.addTypeScore(rightId, TypeEnum_1.TypeEnum.OBJECT);
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.BOOLEAN);
                break;
            }
            case Relation_1.RelationType.Less: // must be numeric
            case Relation_1.RelationType.Greater: // must be numeric
            case Relation_1.RelationType.LessOrEqual: // must be numeric
            case Relation_1.RelationType.GreaterOrEqual: {
                const [leftId, rightId] = involved;
                // most likely numerical
                this._typeModel.addTypeScore(leftId, TypeEnum_1.TypeEnum.NUMERIC);
                this._typeModel.addTypeScore(rightId, TypeEnum_1.TypeEnum.NUMERIC);
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.BOOLEAN);
                break;
            }
            case Relation_1.RelationType.Equality: // could be multiple things
            case Relation_1.RelationType.InEquality: // could be multiple things
            case Relation_1.RelationType.StrictEquality: // could be multiple things
            case Relation_1.RelationType.StrictInequality: {
                const [leftId, rightId] = involved;
                // both sides are likely the same type
                this._typeModel.addWeakRelation(leftId, rightId);
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.BOOLEAN);
                break;
            }
            case Relation_1.RelationType.BitwiseLeftShift: // must be numeric
            case Relation_1.RelationType.BitwiseRightShift: // must be numeric
            case Relation_1.RelationType.BitwiseUnsignedRightShift: // must be numeric
            case Relation_1.RelationType.BitwiseAnd: // must be numeric
            case Relation_1.RelationType.BitwiseOr: // must be numeric
            case Relation_1.RelationType.BitwiseXor: {
                const [leftId, rightId] = involved;
                // most likely numerical
                this._typeModel.addTypeScore(leftId, TypeEnum_1.TypeEnum.NUMERIC);
                this._typeModel.addTypeScore(rightId, TypeEnum_1.TypeEnum.NUMERIC);
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.NUMERIC);
                break;
            }
            case Relation_1.RelationType.LogicalAnd: {
                const [leftId, rightId] = involved;
                // most likely both boolean
                this._typeModel.addTypeScore(leftId, TypeEnum_1.TypeEnum.BOOLEAN);
                this._typeModel.addTypeScore(rightId, TypeEnum_1.TypeEnum.BOOLEAN);
                //can be the boolean or the type of the second one depending on if the first and second are not false/null/undefined
                this._typeModel.addWeakRelation(relationId, leftId);
                this._typeModel.addWeakRelation(relationId, rightId);
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.BOOLEAN);
                // TODO can we say that the leftId and rightId are the same type?
                break;
            }
            case Relation_1.RelationType.LogicalOr: {
                const [leftId, rightId] = involved;
                // most likely both boolean
                this._typeModel.addTypeScore(leftId, TypeEnum_1.TypeEnum.BOOLEAN);
                this._typeModel.addTypeScore(rightId, TypeEnum_1.TypeEnum.BOOLEAN);
                // can be the type of the first or second one depending on if the first is not false/null/undefined
                this._typeModel.addWeakRelation(relationId, leftId);
                this._typeModel.addWeakRelation(relationId, rightId);
                this._typeModel.addTypeScore(relationId, TypeEnum_1.TypeEnum.BOOLEAN);
                this._typeModel.addWeakRelation(leftId, rightId);
                // TODO can we say that the leftId and rightId are the same type?
                break;
            }
            case Relation_1.RelationType.NullishCoalescing: {
                const [leftId, rightId] = involved;
                // left side could be nullish
                this._typeModel.addTypeScore(leftId, TypeEnum_1.TypeEnum.NULL);
                this._typeModel.addTypeScore(leftId, TypeEnum_1.TypeEnum.UNDEFINED);
                // returns the rightId if leftId is nullish
                this._typeModel.addStrongRelation(relationId, leftId);
                this._typeModel.addStrongRelation(relationId, rightId);
                // TODO can we say that the leftId and rightId are the same type?
                this._typeModel.addWeakRelation(leftId, rightId);
                break;
            }
            // ternary
            case Relation_1.RelationType.Conditional: {
                const [conditionId, leftId, rightId] = involved;
                this._typeModel.addTypeScore(conditionId, TypeEnum_1.TypeEnum.BOOLEAN);
                // returns the leftId if conditionId is true
                // returns the rightId if conditionId is false
                this._typeModel.addStrongRelation(relationId, leftId);
                this._typeModel.addStrongRelation(relationId, rightId);
                // can we say that the leftId and rightId are the same type?
                this._typeModel.addWeakRelation(leftId, rightId);
                break;
            }
            case Relation_1.RelationType.Assignment: {
                this._assignment(relation, involved);
                break;
            }
            case Relation_1.RelationType.MultiplicationAssignment: // must be numeric
            case Relation_1.RelationType.ExponentiationAssignment: // must be numeric
            case Relation_1.RelationType.DivisionAssignment: // must be numeric
            case Relation_1.RelationType.RemainderAssigment: // must be numeric
            case Relation_1.RelationType.SubtractionAssignment: // must be numeric
            case Relation_1.RelationType.LeftShiftAssignment: // must be numeric
            case Relation_1.RelationType.RightShiftAssignment: // must be numeric
            case Relation_1.RelationType.UnSignedRightShiftAssignment: // must be numeric
            case Relation_1.RelationType.BitwiseAndAssignment: // must be numeric
            case Relation_1.RelationType.BitwiseXorAssignment: // must be numeric
            case Relation_1.RelationType.BitwiseOrAssignment: {
                this._specialAssignment(relation, involved);
                break;
            }
            case Relation_1.RelationType.AdditionAssignment: {
                this._additionAssignment(relation, involved);
                break;
            }
            case Relation_1.RelationType.LogicalAndAssignment: // could be multiple things
            case Relation_1.RelationType.LogicalOrAssignment: // could be multiple things
            case Relation_1.RelationType.LogicalNullishAssignment: {
                this._logicalAssignment(relation, involved);
                break;
            }
            case Relation_1.RelationType.Yield:
            case Relation_1.RelationType.YieldStar: {
                // TODO
                break;
            }
            case Relation_1.RelationType.Spread: {
                const [spreadId] = involved;
                // is array or object
                this._typeModel.addTypeScore(spreadId, TypeEnum_1.TypeEnum.ARRAY);
                this._typeModel.addTypeScore(spreadId, TypeEnum_1.TypeEnum.OBJECT);
                // TODO results in a sequence of the type of the spread
                break;
            }
            case Relation_1.RelationType.Comma: {
                // TODO
                break;
            }
        }
    }
    _return(relation, involved) {
        const [functionId, argumentId] = involved;
        if (argumentId !== undefined) {
            this._typeModel.addStrongRelation(relation.id, argumentId);
            this._typeModel.addReturnType(functionId, argumentId);
        }
    }
    _call(relation, involved) {
        const [functionId, ...arguments_] = involved;
        // const [functionId] = involved;
        this._typeModel.addTypeScore(functionId, TypeEnum_1.TypeEnum.FUNCTION);
        const type = this._typeModel.getObjectDescription(functionId);
        // relation result is equal to return type of functionId
        for (const returnValueId of type.return) {
            if (relation.id === returnValueId) {
                // recursive function call so we do not add a relation
                continue;
            }
            this._typeModel.addStrongRelation(relation.id, returnValueId);
        }
        // couple function arguments with function parameters
        if (type && type.parameters.size > 0) {
            const smallest = Math.min(arguments_.length, type.parameters.size);
            for (let index = 0; index < smallest; index++) {
                const argumentId = arguments_[index];
                const parameterId = type.parameters.get(index);
                if (argumentId === parameterId) {
                    // recursive function call so we do not add a relation
                    continue;
                }
                this._typeModel.addStrongRelation(parameterId, argumentId);
            }
        }
    }
    _objectProperty(elementMap, relation, involved) {
        const [propertyId, valueId] = involved;
        const propertyElement = elementMap.get(propertyId);
        if (propertyElement) {
            const propertyName = "name" in propertyElement
                ? propertyElement.name
                : propertyElement.value;
            this._typeModel.addPropertyType(relation.id, propertyName, propertyId);
        }
        else {
            // TODO what if the property is not an element (spread element for example)
        }
        // connect property to value
        if (valueId !== undefined && valueId !== propertyId) {
            this._typeModel.addStrongRelation(propertyId, valueId);
        }
    }
    _objectMethod(elementMap, relationMap, relation, involved) {
        const [functionId, ...parameters] = involved;
        // TODO what if the property is not an element
        const propertyElement = elementMap.get(functionId);
        const propertyName = "name" in propertyElement ? propertyElement.name : propertyElement.value;
        this._typeModel.addPropertyType(relation.id, propertyName, functionId);
        this.addFunctionParameters(elementMap, relationMap, functionId, parameters);
    }
    _classProperty(elementMap, involved) {
        if (involved.length < 2) {
            throw new Error(`Class property relation should have at least 2 elements, but has ${involved.length}`);
        }
        const [classId, propertyId, valueId] = involved;
        // TODO what if the property is not an element
        const propertyElement = elementMap.get(propertyId);
        const propertyName = "name" in propertyElement ? propertyElement.name : propertyElement.value;
        // make object for the class
        this._typeModel.addPropertyType(classId, propertyName, propertyId);
        // connect property to value
        if (valueId !== undefined) {
            this._typeModel.addStrongRelation(propertyId, valueId);
        }
    }
    _classMethod(elementMap, relationMap, involved) {
        if (involved.length < 2) {
            throw new Error(`Class method relation should have at least 2 elements, but has ${involved.length}`);
        }
        const [, functionId, ...parameters] = involved;
        // const [classId, functionId, ...parameters] = involved;
        // TODO the following does not work because the element refers to the identifier of the method
        // BUT we do not record the ids as such we actually record the id of the entire function
        // // TODO what if the function id is not an element
        // const propertyElement = this.getElement(functionId);
        // const propertyName =
        //   "name" in propertyElement
        //     ? propertyElement.name
        //     : propertyElement.value;
        // this._typeModel.addProperty(classId, propertyName, functionId);
        // TODO maybe not for setter / getter
        // make function for the method
        this.addFunctionParameters(elementMap, relationMap, functionId, parameters);
    }
    _arrayPattern(relation, involved) {
        const elements = involved;
        this._typeModel.addTypeScore(relation.id, TypeEnum_1.TypeEnum.ARRAY);
        // create array type
        for (const id of elements) {
            this._typeModel.addElementType(relation.id, id);
        }
    }
    _for(involved) {
        const conditionId = involved[0];
        if (conditionId !== undefined) {
            // add boolean type to condition
            this._typeModel.addTypeScore(conditionId, TypeEnum_1.TypeEnum.BOOLEAN);
        }
    }
    _forIn(involved) {
        const [declarator, arrayOrObject] = involved;
        this._typeModel.addTypeScore(arrayOrObject, TypeEnum_1.TypeEnum.ARRAY);
        this._typeModel.addTypeScore(arrayOrObject, TypeEnum_1.TypeEnum.OBJECT);
        const objectDescription = this._typeModel.getObjectDescription(arrayOrObject);
        for (const id of objectDescription.elements.values()) {
            // connect declarator to array element
            this._typeModel.addWeakRelation(declarator, id);
        }
        for (const id of objectDescription.properties.values()) {
            // connect declarator to object property
            this._typeModel.addWeakRelation(declarator, id);
        }
    }
    _forOf(involved) {
        const [declarator, array] = involved;
        this._typeModel.addTypeScore(array, TypeEnum_1.TypeEnum.ARRAY);
        const typeOfArray = this._typeModel.getObjectDescription(array);
        for (const id of typeOfArray.elements.values()) {
            // connect declarator to array element
            this._typeModel.addWeakRelation(declarator, id);
        }
    }
    _switch(involved) {
        const [discriminant, ...cases] = involved;
        for (const case_ of cases) {
            this._typeModel.addWeakRelation(discriminant, case_);
        }
    }
    _propertyAccessor(elementMap, relation, involved, originalInvolved) {
        const [objectId, propertyId] = involved;
        const [, originalProperty] = originalInvolved;
        const propertyElement = elementMap.get(originalProperty);
        if (propertyElement === undefined) {
            // e.g. object[b ? 1 : 0]
            // the property is not an element
            this._typeModel.addTypeScore(objectId, TypeEnum_1.TypeEnum.STRING);
            this._typeModel.addTypeScore(objectId, TypeEnum_1.TypeEnum.ARRAY);
            this._typeModel.addTypeScore(objectId, TypeEnum_1.TypeEnum.OBJECT, 2);
        }
        else
            switch (propertyElement.type) {
                case Element_1.ElementType.NumericalLiteral: {
                    // e.g. object[0]
                    // add array type to object
                    this._typeModel.addElementType(objectId, relation.id);
                    break;
                }
                case Element_1.ElementType.StringLiteral: {
                    // e.g. object["abc"]
                    // add array type to object
                    this._typeModel.addPropertyType(objectId, propertyElement.value, propertyId);
                    break;
                }
                case Element_1.ElementType.Identifier: {
                    if (relation.computed) {
                        // e.g. object[abc]
                        // not allowed dynamic stuff happening
                        // or we can check wether abc is a number
                        // add the defaults
                        this._typeModel.addTypeScore(objectId, TypeEnum_1.TypeEnum.STRING);
                        this._typeModel.addTypeScore(objectId, TypeEnum_1.TypeEnum.ARRAY);
                        this._typeModel.addTypeScore(objectId, TypeEnum_1.TypeEnum.OBJECT, 2);
                    }
                    else {
                        // e.g. object.abc
                        this._typeModel.addPropertyType(objectId, propertyElement.name, propertyId);
                    }
                    break;
                }
                // No default
            }
        // we don't have to connect the relationid to the propertyId since they are equal already
        this._typeModel.addStrongRelation(relation.id, propertyId);
        // this._typeModel.setEqual(relation.id, propertyId)
    }
    _assignment(relation, involved) {
        // should always have two involved
        if (involved.length !== 2) {
            throw new Error(`Assignment relation should have two involved, but has ${involved.length}. ${relation.id}`);
        }
        const [leftId, rightId] = involved;
        if (leftId !== rightId) {
            this._typeModel.addStrongRelation(leftId, rightId);
        }
        // undefined should be the actual result
        // this._typeModel.addPrimitiveTypeScore(relationId, {
        //   type: TypeEnum.UNDEFINED,
        // });
        // this._typeModel.setEqual(leftId, relationId);
        // this._typeModel.addStrongRelation(relationId, leftId);
        this._typeModel.addTypeScore(relation.id, TypeEnum_1.TypeEnum.UNDEFINED);
    }
    _specialAssignment(relation, involved) {
        this._assignment(relation, involved);
        const [leftId, rightId] = involved;
        // likely numeric
        this._typeModel.addTypeScore(leftId, TypeEnum_1.TypeEnum.NUMERIC);
        this._typeModel.addTypeScore(rightId, TypeEnum_1.TypeEnum.NUMERIC);
    }
    _additionAssignment(relation, involved) {
        this._specialAssignment(relation, involved);
        const [leftId, rightId] = involved;
        // likely string
        this._typeModel.addTypeScore(leftId, TypeEnum_1.TypeEnum.STRING);
        this._typeModel.addTypeScore(rightId, TypeEnum_1.TypeEnum.STRING);
    }
    _logicalAssignment(relation, involved) {
        if (involved.length !== 2) {
            throw new Error(`Assignment relation should have two involved, but has ${involved.length}`);
        }
        const [leftId, rightId] = involved;
        this._typeModel.addWeakRelation(leftId, rightId);
        // likely boolean
        this._typeModel.addTypeScore(leftId, TypeEnum_1.TypeEnum.BOOLEAN);
        this._typeModel.addTypeScore(rightId, TypeEnum_1.TypeEnum.BOOLEAN);
        this._typeModel.addTypeScore(relation.id, TypeEnum_1.TypeEnum.UNDEFINED);
    }
    addFunctionParameters(elementMap, relationMap, functionId, parameters) {
        // create function type
        for (const [index, id] of parameters.entries()) {
            let name;
            const element = elementMap.get(id);
            if (element) {
                name = "name" in element ? element.name : element.value;
            }
            if (!name) {
                const relation = relationMap.get(id);
                if (relation) {
                    name = (0, Relation_1.getRelationName)(relation.type);
                }
                else {
                    throw new Error(`Could not find element or relation with id ${id}`);
                }
            }
            this._typeModel.addParameterType(functionId, index, id, name);
        }
    }
}
exports.InferenceTypeModelFactory = InferenceTypeModelFactory;
//# sourceMappingURL=InferenceTypeModelFactory.js.map