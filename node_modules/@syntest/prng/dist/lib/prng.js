"use strict";
/*
 * Copyright 2020-2021 Delft University of Technology and SynTest contributors
 *
 * This file is part of SynTest Framework - SynTest Core.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.prng = exports.initializePseudoRandomNumberGenerator = void 0;
const bignumber_js_1 = require("bignumber.js");
const seedrandom = require("seedrandom");
const Charset_1 = require("./Charset");
const diagnostics_1 = require("./diagnostics");
let random;
function initializePseudoRandomNumberGenerator(seed) {
    if (random) {
        throw new Error((0, diagnostics_1.singletonAlreadySet)("PseudoRandomNumberGenerator"));
    }
    random = seedrandom(seed);
    Math.random = random;
}
exports.initializePseudoRandomNumberGenerator = initializePseudoRandomNumberGenerator;
function generator() {
    if (!random) {
        throw new Error((0, diagnostics_1.singletonNotSet)("PseudoRandomNumberGenerator"));
    }
    return random();
}
/**
 * The global random generator.
 */
exports.prng = {
    nextBoolean: (trueChance = 0.5) => {
        return generator() <= trueChance;
    },
    nextInt: (min = 0, max = Number.MAX_SAFE_INTEGER) => {
        const value = generator();
        return Math.round(value * (max - min)) + min;
    },
    nextBigInt: (min = new bignumber_js_1.default(0), max = new bignumber_js_1.default(Number.MAX_SAFE_INTEGER)) => {
        const value = new bignumber_js_1.default(generator());
        return value.multipliedBy(max.minus(min)).plus(min).integerValue();
    },
    nextDouble: (min = 0, max = Number.MAX_SAFE_INTEGER) => {
        const value = generator();
        return value * (max - min) + min;
    },
    nextBigDouble: (min = new bignumber_js_1.default(0), max = new bignumber_js_1.default(Number.MAX_SAFE_INTEGER)) => {
        const value = new bignumber_js_1.default(generator());
        return value.multipliedBy(max.minus(min)).plus(min);
    },
    /**
     * Uses the Box-Muller transform to get a gaussian random variable.
     *
     * Based on:
     * https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform
     */
    nextGaussian: (mu = 0, sigma = 1) => {
        const u1 = generator();
        const u2 = generator();
        const mag = sigma * Math.sqrt(-2 * Math.log(u1));
        return mag * Math.cos(2 * Math.PI * u2) + mu;
    },
    pickOne: (options) => {
        if (options.length === 0) {
            throw new Error((0, diagnostics_1.emptyArray)("options"));
        }
        const value = generator();
        const index = Math.round(value * (options.length - 1));
        return options[index];
    },
    uniqueId: (length = 7, characters = Charset_1.Charset.alpha + Charset_1.Charset.alphaCapital) => {
        const charactersLength = characters.length;
        let result = "";
        for (let index = 0; index < length; index++) {
            result += characters.charAt(Math.floor(generator() * charactersLength));
        }
        return result;
    },
};
//# sourceMappingURL=prng.js.map