"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLogger = exports.setupLogger = void 0;
/*
 * Copyright 2020-2023 Delft University of Technology and SynTest contributors
 *
 * This file is part of SynTest Framework - SynTest Core.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const path = require("node:path");
const winston_1 = require("winston");
let singletonLogger;
function setupLogger(logDirectory, fileLogLevel, consoleLogLevel) {
    const fileTransportOptions = {
        maxsize: 5242880,
        maxFiles: 1,
    };
    const baseLoggerOptions = {
        levels: {
            error: 0,
            warn: 1,
            info: 2,
            debug: 3,
            verbose: 4,
            silly: 5,
        },
        silent: false,
        exitOnError: false,
        format: winston_1.format.combine(winston_1.format.timestamp(), winston_1.format.json(), winston_1.format.metadata(), winston_1.format.errors({ stack: true })),
        transports: fileLogLevel.map((logLevel) => new winston_1.transports.File({
            ...fileTransportOptions,
            level: logLevel,
            filename: path.join(logDirectory, `${logLevel}.log`),
        })),
    };
    if (consoleLogLevel !== "silent") {
        baseLoggerOptions.transports.push(new winston_1.transports.Console({
            format: winston_1.format.cli(),
            level: consoleLogLevel,
            stderrLevels: ["fatal", "error", "warn"],
            debugStdout: false,
        }));
    }
    singletonLogger = (0, winston_1.createLogger)(baseLoggerOptions);
}
exports.setupLogger = setupLogger;
function getLogger(context) {
    if (singletonLogger === undefined) {
        throw new Error("Should call setupLogger function before using getLogger function!");
    }
    return new SubLogger(context);
}
exports.getLogger = getLogger;
/**
 * We use the winston logger singleton in each sublogger.
 * We do this to prevent memory leaks since each instance of a winston logger registers a bunch of event listeners.
 */
class SubLogger {
    constructor(context) {
        this._context = context;
    }
    error(message) {
        singletonLogger.log({
            level: "error",
            message: message,
            meta: { context: this._context },
        });
    }
    warn(message) {
        singletonLogger.log({
            level: "warn",
            message: message,
            meta: { context: this._context },
        });
    }
    info(message) {
        singletonLogger.log({
            level: "info",
            message: message,
            meta: { context: this._context },
        });
    }
    debug(message) {
        singletonLogger.log({
            level: "debug",
            message: message,
            meta: { context: this._context },
        });
    }
    silly(message) {
        singletonLogger.log({
            level: "silly",
            message: message,
            meta: { context: this._context },
        });
    }
}
//# sourceMappingURL=logger.js.map