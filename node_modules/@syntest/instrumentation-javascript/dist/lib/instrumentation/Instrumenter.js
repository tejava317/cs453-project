"use strict";
/*
 * Copyright 2020-2023 Delft University of Technology and SynTest contributors
 *
 * This file is part of SynTest Framework - SynTest Javascript.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Instrumenter = void 0;
const core_1 = require("@babel/core");
const Visitor_1 = require("./Visitor");
const analysis_javascript_1 = require("@syntest/analysis-javascript");
const path = require("node:path");
class Instrumenter {
    // TODO maybe the instrumenter should not be responsible for copying the files
    async instrumentAll(storageManager, rootContext, targets, instrumentedDirectory) {
        const absoluteRootPath = path.resolve(rootContext.rootPath);
        const destinationPath = path.join(instrumentedDirectory, path.basename(absoluteRootPath));
        // copy everything
        storageManager.copyToTemporaryDirectory([absoluteRootPath], [...destinationPath.split(path.sep)]);
        // overwrite the stuff that needs instrumentation
        const targetPaths = [...targets.values()].map((target) => target.path);
        for (const targetPath of targetPaths) {
            const source = rootContext.getSource(targetPath);
            const instrumentedSource = await this.instrument(source, targetPath);
            const _path = path
                .normalize(targetPath)
                .replace(absoluteRootPath, destinationPath);
            const directory = path.dirname(_path);
            const file = path.basename(_path);
            storageManager.store([...directory.split(path.sep)], file, instrumentedSource, true);
        }
    }
    async instrument(code, filename) {
        const options = JSON.parse(JSON.stringify(analysis_javascript_1.defaultBabelOptions));
        let output = {};
        options.filename = filename;
        options.plugins.push([
            ({ types }) => {
                const ee = new Visitor_1.Visitor(types, filename, {
                    coverageVariable: "__coverage__",
                    // reportLogic: opts.reportLogic,
                    // coverageGlobalScope: opts.coverageGlobalScope,
                    // coverageGlobalScopeFunc: opts.coverageGlobalScopeFunc,
                    ignoreClassMethods: [],
                    // inputSourceMap
                });
                return {
                    visitor: {
                        Program: {
                            enter: (path) => ee.enter(path),
                            exit(path) {
                                output = ee.exit(path);
                            },
                        },
                    },
                };
            },
        ]);
        const codeMap = await (0, core_1.transformSync)(code, options);
        if (!output || !output.fileCoverage) {
            return code;
        }
        return codeMap.code;
    }
}
exports.Instrumenter = Instrumenter;
//# sourceMappingURL=Instrumenter.js.map